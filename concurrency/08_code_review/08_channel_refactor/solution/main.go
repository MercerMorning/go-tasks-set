package main

import (
	"fmt"
	"sync"
)

func main() {
	demonstrateOriginal()
	fmt.Println("\n=== Исправленная версия ===")
	demonstrateFixed()
}

// ПРОБЛЕМЫ ОРИГИНАЛЬНОГО КОДА:
//
// 1. Бесконечный цикл (строка 26-31)
//    for { select { case result := <-a: ... } }
//    Проблема: Цикл никогда не завершится, wc.Wait() не выполнится
//    Решение: Закрыть канал после завершения горутин и использовать range
//
// 2. Deadlock через 5 итераций
//    Канал имеет буфер 3, но запускаем 5 горутин
//    Проблема: 3 горутины запишут в буфер, 2 заблокируются в ожидании
//    Но никто не читает из канала (бесконечный цикл не доходит до чтения)
//    Результат: Deadlock
//
// 3. Ненужный мьютекс fff
//    Проблема: Мьютекс блокирует отправку в канал, что бессмысленно
//    Канал сам потокобезопасен
//    Решение: Убрать мьютекс
//
// 4. Передача wc по указателю не нужна
//    Проблема: WaitGroup обычно передается по значению в defer
//    Решение: Использовать замыкание или не передавать явно
//
// 5. strconv.Itoa не нужен
//    Проблема: fmt.Sprintf("%s", strconv.Itoa(i)) можно заменить на fmt.Sprintf("%d", i)
//    Решение: Использовать прямое форматирование
//
// 6. Нет переноса строки в Printf
//    Проблема: Вывод слипнется
//    Решение: Использовать fmt.Println или добавить \n

func demonstrateOriginal() {
	fmt.Println("=== Оригинальный код (с фиксом deadlock) ===")

	var wc sync.WaitGroup
	// fff := sync.Mutex{} // Ненужный мьютекс
	a := make(chan string, 3)

	// Запускаем 5 горутин, но канал имеет буфер только 3
	for i := 0; i < 5; i++ {
		wc.Add(1)
		go func(i int) {
			defer wc.Done()
			// fff.Lock() // Ненужный мьютекс
			a <- fmt.Sprintf("Current goroutine number: %d", i)
			// fff.Unlock()
		}(i)
	}

	// Запускаем чтение в отдельной горутине чтобы избежать deadlock
	go func() {
		wc.Wait()
		close(a)
	}()

	// Читаем из канала до его закрытия
	for result := range a {
		fmt.Println(result)
	}
}

// ПРАВИЛЬНАЯ РЕАЛИЗАЦИЯ
func demonstrateFixed() {
	var wg sync.WaitGroup
	results := make(chan string, 5) // Буфер достаточный для всех результатов

	// Запускаем горутины
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			results <- fmt.Sprintf("Goroutine %d completed", i)
		}(i)
	}

	// Закрываем канал после завершения всех горутин
	go func() {
		wg.Wait()
		close(results)
	}()

	// Читаем результаты до закрытия канала
	for result := range results {
		fmt.Println(result)
	}

	fmt.Println("All goroutines completed")
}

// Ответ на вопрос "Что выведет":
// Оригинальный код вызовет DEADLOCK!
//
// Причина:
// 1. Запускаем 5 горутин с буферизированным каналом размером 3
// 2. Первые 3 горутины успешно отправляют в канал (буфер заполнен)
// 3. Горутины 4 и 5 блокируются в ожидании места в канале
// 4. Основная горутина застревает в бесконечном цикле for {}
// 5. Никто не читает из канала
// 6. Горутины 4 и 5 ждут вечно
// 7. wc.Wait() никогда не выполнится
// 8. Go runtime обнаружит deadlock и паникнет
//
// fatal error: all goroutines are asleep - deadlock!
