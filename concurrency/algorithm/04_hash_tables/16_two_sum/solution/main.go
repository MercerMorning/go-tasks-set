package main

import "fmt"

// ============================================================================
// Решение 1: Hash Set (оптимальное) - O(n)
// ============================================================================

func HasSum(nums []int, target int) bool {
	seen := make(map[int]bool)

	for _, num := range nums {
		complement := target - num
		if seen[complement] {
			return true
		}
		seen[num] = true
	}

	return false
}

// ============================================================================
// Решение 2: Brute Force (два вложенных цикла) - O(n²)
// ============================================================================

func HasSumBruteForce(nums []int, target int) bool {
	for i := 0; i < len(nums); i++ {
		for j := i + 1; j < len(nums); j++ {
			if nums[i]+nums[j] == target {
				return true
			}
		}
	}
	return false
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение 1: Hash Set O(n) ===")
	testHasSum(HasSum)

	fmt.Println("\n=== Решение 2: Brute Force O(n²) ===")
	testHasSum(HasSumBruteForce)

	fmt.Println("\n=== Визуализация процесса ===")
	visualizeTwoSum()
}

func testHasSum(fn func([]int, int) bool) {
	testCases := []struct {
		nums     []int
		target   int
		expected bool
	}{
		{[]int{10, 15, 3, 7}, 17, true},
		{[]int{1, 2, 3, 4, 5, 6}, 12, false},
		{[]int{5, 5}, 10, true},
		{[]int{1, 2, 3}, 7, false},
		{[]int{2, 7, 11, 15}, 9, true},
	}

	for i, tc := range testCases {
		result := fn(tc.nums, tc.target)
		status := "✅"
		if result != tc.expected {
			status = "❌"
		}
		fmt.Printf("%s Тест %d: nums=%v, target=%d → %v (expected %v)\n",
			status, i+1, tc.nums, tc.target, result, tc.expected)
	}
}

func visualizeTwoSum() {
	nums := []int{10, 15, 3, 7}
	target := 17

	fmt.Printf("Поиск двух чисел, дающих сумму %d в массиве %v\n\n", target, nums)

	fmt.Println("Метод 1: Hash Set")
	seen := make(map[int]bool)

	for i, num := range nums {
		complement := target - num
		fmt.Printf("Шаг %d: num=%d, complement=%d\n", i+1, num, complement)
		fmt.Printf("  Проверяем: есть ли %d в seen? ", complement)

		if seen[complement] {
			fmt.Printf("ДА! Найдена пара: %d + %d = %d ✓\n", complement, num, target)
			break
		}
		fmt.Printf("Нет\n")
		fmt.Printf("  Добавляем %d в seen\n", num)
		seen[num] = true
		fmt.Printf("  seen = %v\n\n", mapKeys(seen))
	}
}

func mapKeys(m map[int]bool) []int {
	keys := make([]int, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// ============================================================================
// Объяснение решений
// ============================================================================

// РЕШЕНИЕ 1: Hash Set (ОПТИМАЛЬНОЕ)
//
// ============================================================================
// ВЫСОКОУРОВНЕВАЯ ИДЕЯ
// ============================================================================
//
// Задача: найти две числа в массиве, которые в сумме дают target
// Наивный подход: проверить все пары O(n²)
// Оптимизация: используем hash set для быстрого поиска complement
//
// Ключевая идея:
// - Для каждого числа num вычисляем complement = target - num
// - Если complement уже встречали ранее → пара найдена
// - Иначе добавляем num в множество "увиденных"
//
// Алгоритм:
// 1. Создаем пустое множество seen
// 2. Для каждого числа num в массиве:
//    - Вычисляем complement = target - num
//    - Если complement в seen → возвращаем true
//    - Добавляем num в seen
// 3. Если прошли весь массив → возвращаем false
//
// ============================================================================
// ДЕТАЛЬНЫЙ РАЗБОР КОДА
// ============================================================================
//
// func HasSum(nums []int, target int) bool {
//     seen := make(map[int]bool)
//
// СТРОКА 1: Создание hash set
// - В Go используем map[int]bool как set
// - Ключ — число, значение — всегда true (наличие в множестве)
// - Альтернатива: map[int]struct{} (экономит память, но менее читаемо)
//
//     for _, num := range nums {
//         complement := target - num
//
// СТРОКА 2-3: Вычисление complement
// - Если num + complement = target
// - То complement = target - num
// - Пример: target=17, num=10 → complement=7
//
// ПОЧЕМУ ЭТО РАБОТАЕТ:
// Если в массиве есть числа a и b, где a + b = target, то:
// - Когда обрабатываем a: complement = target - a = b
// - Если b уже в seen → нашли пару
// - Когда обрабатываем b: complement = target - b = a
// - Если a уже в seen → нашли пару
//
//         if seen[complement] {
//             return true
//         }
//
// СТРОКА 4-6: Проверка наличия complement
// - Обращение к map[key] в Go:
//   - Если ключ существует → возвращает значение (true) и true
//   - Если ключ НЕ существует → возвращает zero value (false) и false
// - Здесь используем первое возвращаемое значение (само значение)
// - Если complement в seen → пара найдена, возвращаем true
//
// ВАЖНО: Проверяем ПЕРЕД добавлением текущего num в seen
// Почему? Чтобы не найти одно и то же число дважды
// Пример: nums=[5], target=10
// - Если добавим 5 в seen, а потом ищем complement=5 → найдем false positive
//
//         seen[num] = true
//     }
//
// СТРОКА 7-8: Добавление num в seen
// - Только если complement не найден
// - Теперь num доступен для поиска в следующих итерациях
//
//     return false
// }
//
// СТРОКА 9: Пара не найдена
// - Прошли весь массив, не нашли complement ни для одного числа
// - Возвращаем false
//
// ============================================================================
// ПРИМЕР РАБОТЫ
// ============================================================================
//
// nums = [10, 15, 3, 7], target = 17
//
// ИТЕРАЦИЯ 1: num = 10
// - complement = 17 - 10 = 7
// - seen = {} (пусто)
// - 7 в seen? НЕТ
// - Добавляем 10 в seen
// - seen = {10}
//
// ИТЕРАЦИЯ 2: num = 15
// - complement = 17 - 15 = 2
// - seen = {10}
// - 2 в seen? НЕТ
// - Добавляем 15 в seen
// - seen = {10, 15}
//
// ИТЕРАЦИЯ 3: num = 3
// - complement = 17 - 3 = 14
// - seen = {10, 15}
// - 14 в seen? НЕТ
// - Добавляем 3 в seen
// - seen = {10, 15, 3}
//
// ИТЕРАЦИЯ 4: num = 7
// - complement = 17 - 7 = 10
// - seen = {10, 15, 3}
// - 10 в seen? ДА! ✓
// - Возвращаем true
// - Нашли пару: 10 + 7 = 17
//
// ============================================================================
// СЛОЖНОСТЬ
// ============================================================================
//
// Временная сложность: O(n)
// - Один проход по массиву: n итераций
// - Каждая итерация:
//   - Вычисление complement: O(1)
//   - Проверка в hash map: O(1) amortized
//   - Добавление в hash map: O(1) amortized
// - Итого: n × O(1) = O(n)
//
// ПОЧЕМУ hash map операции O(1)?
// - Хеш-таблица обеспечивает константный доступ в среднем
// - В худшем случае (много коллизий): O(n)
// - Но amortized сложность: O(1)
//
// Пространственная сложность: O(n)
// - В худшем случае добавляем все n элементов в seen
// - Пример: nums=[1,2,3,4,5], target=100
//   - Ни одна пара не найдена
//   - seen будет содержать все 5 элементов
// - Размер hash map растет линейно с размером входа
// - O(n) дополнительной памяти
//
// ============================================================================
// CORNER CASES
// ============================================================================
//
// CASE 1: Два одинаковых числа
// Input: nums = [5, 5], target = 10
// Ожидаем: true
//
// Итерация 1: num=5
// - complement = 10 - 5 = 5
// - seen = {}
// - 5 в seen? НЕТ
// - seen = {5}
//
// Итерация 2: num=5
// - complement = 10 - 5 = 5
// - seen = {5}
// - 5 в seen? ДА! ✓
// - Нашли пару: 5 + 5 = 10
//
// Работает корректно! Первое 5 добавляется в seen, второе 5 находит его.
//
// ============================================================================
//
// CASE 2: Одно число (нужно использовать дважды)
// Input: nums = [5], target = 10
// Ожидаем: false (нельзя использовать одно и то же число дважды)
//
// Итерация 1: num=5
// - complement = 10 - 5 = 5
// - seen = {}
// - 5 в seen? НЕТ ✓
// - seen = {5}
//
// Возвращаем false ✓
//
// ПОЧЕМУ РАБОТАЕТ:
// - Проверяем complement ПЕРЕД добавлением num в seen
// - Таким образом исключаем использование одного элемента дважды
//
// ЕСЛИ БЫ добавляли ПЕРЕД проверкой:
// seen[num] = true
// if seen[complement] { ... }  // FALSE POSITIVE для [5]
//
// ============================================================================
//
// CASE 3: Пустой массив
// Input: nums = [], target = 10
// Ожидаем: false
//
// Цикл не выполняется (len(nums) = 0)
// Возвращаем false ✓
//
// ============================================================================
//
// CASE 4: Нет пары
// Input: nums = [1, 2, 3], target = 10
// Ожидаем: false
//
// Проходим все элементы, complement не найден ни для одного
// seen = {1, 2, 3} в конце
// Возвращаем false ✓
//
// ============================================================================
//
// CASE 5: Несколько пар
// Input: nums = [1, 2, 3, 4], target = 5
// Ожидаем: true (пары: 1+4, 2+3)
//
// Итерация 1: num=1, complement=4, seen={}, добавляем 1, seen={1}
// Итерация 2: num=2, complement=3, seen={1}, добавляем 2, seen={1,2}
// Итерация 3: num=3, complement=2, seen={1,2}, 2 в seen? ДА! ✓
//
// Находим ПЕРВУЮ встретившуюся пару (2+3)
// Не проверяем остальные элементы (эффективно!)
//
// ============================================================================
// РЕШЕНИЕ 2: Brute Force
// ============================================================================
//
// Идея:
// - Проверяем все возможные пары элементов
// - Два вложенных цикла: внешний (i) и внутренний (j)
// - Для каждой пары (i, j) проверяем: nums[i] + nums[j] == target
//
// Почему j = i + 1?
// - Избегаем повторных проверок: пара (i,j) = пара (j,i)
// - Избегаем использования одного элемента дважды: i != j
//
// Временная сложность: O(n²)
// - Внешний цикл: n итераций
// - Внутренний цикл: в среднем n/2 итераций
// - Итого: n × (n/2) = n²/2 = O(n²)
//
// Точное количество проверок:
// (n-1) + (n-2) + ... + 1 = n(n-1)/2
//
// Для n=100: ~5000 проверок
// Для n=1000: ~500,000 проверок
// Для n=10000: ~50,000,000 проверок
//
// Пространственная сложность: O(1)
// - Используем только переменные i, j
// - Не создаем дополнительных структур данных
//
// Плюсы:
// - Простая реализация
// - O(1) памяти
// - Не требует дополнительных структур данных
//
// Минусы:
// - Медленно для больших массивов
// - O(n²) — неприемлемо для n > 10,000
//
// ============================================================================
// СРАВНЕНИЕ РЕШЕНИЙ
// ============================================================================
//
// Критерий          | Hash Set  | Brute Force
// ------------------|-----------|------------
// Время             | O(n)      | O(n²)
// Память            | O(n)      | O(1)
// Читаемость        | ★★★★      | ★★★★★
// Эффективность     | ★★★★★     | ★★
// Для малых n       | Overkill  | Достаточно
// Для больших n     | Отлично   | Плохо
//
// РЕКОМЕНДАЦИЯ:
// - Используйте Hash Set (Решение 1)
// - O(n) время стоит O(n) памяти
// - Для n=1,000,000: Hash Set ~1ms, Brute Force ~10 минут
//
// ============================================================================
// МОДИФИКАЦИИ ЗАДАЧИ
// ============================================================================
//
// 1. ВЕРНУТЬ ИНДЕКСЫ ВМЕСТО BOOL
// func TwoSum(nums []int, target int) []int {
//     seen := make(map[int]int)  // число → индекс
//     for i, num := range nums {
//         complement := target - num
//         if j, ok := seen[complement]; ok {
//             return []int{j, i}
//         }
//         seen[num] = i
//     }
//     return nil
// }
//
// 2. НАЙТИ ВСЕ ПАРЫ (НЕ ОСТАНАВЛИВАТЬСЯ НА ПЕРВОЙ)
// func TwoSumAll(nums []int, target int) [][]int {
//     seen := make(map[int]bool)
//     pairs := [][]int{}
//     for _, num := range nums {
//         complement := target - num
//         if seen[complement] {
//             pairs = append(pairs, []int{complement, num})
//         }
//         seen[num] = true
//     }
//     return pairs
// }
//
// 3. THREE SUM (РАСШИРЕНИЕ ДЛЯ ТРЕХ ЧИСЕЛ)
// func ThreeSum(nums []int, target int) bool {
//     for i := 0; i < len(nums); i++ {
//         // Для каждого nums[i] ищем Two Sum с target-nums[i]
//         if TwoSumExcluding(nums, i, target-nums[i]) {
//             return true
//         }
//     }
//     return false
// }
//
// ============================================================================
// ПРИМЕНЕНИЕ В РЕАЛЬНЫХ ЗАДАЧАХ
// ============================================================================
//
// 1. ПОИСК ПАРЫ ТОВАРОВ ПОД БЮДЖЕТ
//    - Список цен товаров
//    - Бюджет = target
//    - Найти два товара, которые можно купить на бюджет
//
// 2. КРИПТОГРАФИЯ
//    - Поиск коллизий в хеш-функциях
//    - Две строки с одинаковым хешем
//
// 3. БАЛАНСИРОВКА НАГРУЗКИ
//    - Два сервера с суммарной нагрузкой = target
//    - Распределение задач
//
// 4. MATCHING СИСТЕМЫ
//    - Поиск совместимых пар пользователей
//    - Скиллы складываются в нужную сумму
//
// ============================================================================
