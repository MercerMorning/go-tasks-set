package main

import "fmt"

// ============================================================================
// Решение: Фильтрация через map для быстрого поиска
// ============================================================================

func filterSellersByCities(sellers map[int][]string, cities []string) map[int][]string {
	// Создаем map для быстрого поиска городов O(1)
	citySet := make(map[string]bool)
	for _, city := range cities {
		citySet[city] = true
	}

	result := make(map[int][]string)

	// Проходим по всем продавцам
	for sellerID, sellerCities := range sellers {
		filteredCities := []string{}

		// Фильтруем города продавца, оставляя только те, что в cities
		for _, city := range sellerCities {
			if citySet[city] {
				filteredCities = append(filteredCities, city)
			}
		}

		// Добавляем в результат только если есть совпадения
		if len(filteredCities) > 0 {
			result[sellerID] = filteredCities
		}
	}

	return result
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение: Фильтрация продавцов по городам ===")
	testFilterSellersByCities()
}

func testFilterSellersByCities() {
	sellers := map[int][]string{
		1: {"Москва", "Самара", "Ростов"},
		2: {"Москва", "Самара", "Ростов", "Казань", "Курган", "Пенза"},
		3: {"Самара", "Ростов", "Курган", "Пенза"},
		4: {"Москва", "Казань", "Тула"},
	}
	cities := []string{"Москва", "Казань", "Тула"}

	result := filterSellersByCities(sellers, cities)
	fmt.Printf("Результат: %v\n", result)

	// Ожидается: {1: ["Москва"], 2: ["Москва", "Казань"], 4: ["Москва", "Казань", "Тула"]}
	expected := map[int][]string{
		1: {"Москва"},
		2: {"Москва", "Казань"},
		4: {"Москва", "Казань", "Тула"},
	}

	status := "✅"
	if len(result) != len(expected) {
		status = "❌"
	} else {
		for sellerID, expectedCities := range expected {
			if actualCities, ok := result[sellerID]; !ok || !stringSlicesEqual(actualCities, expectedCities) {
				status = "❌"
				break
			}
		}
	}
	fmt.Printf("%s Тест пройден\n", status)
}

func stringSlicesEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// ============================================================================
// Объяснение решения
// ============================================================================

// РЕШЕНИЕ: Фильтрация через map для быстрого поиска
//
// Идея:
// - Создаем set (map[string]bool) из списка интересующих городов для O(1) поиска
// - Проходим по всем продавцам и фильтруем их города
// - Оставляем только те города, которые есть в cities
//
// Алгоритм:
// 1. Создаем citySet из cities для быстрого поиска O(1)
// 2. Для каждого продавца:
//    - Проходим по его городам
//    - Если город есть в citySet, добавляем в результат
//    - Если есть совпадения, добавляем продавца в результат
// 3. Возвращаем отфильтрованный map
//
// Пример работы:
// sellers = {
//   1: ["Москва", "Самара", "Ростов"],
//   2: ["Москва", "Самара", "Ростов", "Казань", "Курган", "Пенза"],
//   3: ["Самара", "Ростов", "Курган", "Пенза"],
//   4: ["Москва", "Казань", "Тула"]
// }
// cities = ["Москва", "Казань", "Тула"]
//
// Шаг 1: Создаем citySet
//   citySet = {"Москва": true, "Казань": true, "Тула": true}
//
// Шаг 2: Обрабатываем продавца 1
//   Города: ["Москва", "Самара", "Ростов"]
//   Фильтруем: "Москва" в citySet? Да → добавляем
//              "Самара" в citySet? Нет → пропускаем
//              "Ростов" в citySet? Нет → пропускаем
//   result[1] = ["Москва"]
//
// Шаг 3: Обрабатываем продавца 2
//   Города: ["Москва", "Самара", "Ростов", "Казань", "Курган", "Пенза"]
//   Фильтруем: "Москва" → да, "Казань" → да
//   result[2] = ["Москва", "Казань"]
//
// Шаг 4: Обрабатываем продавца 3
//   Города: ["Самара", "Ростов", "Курган", "Пенза"]
//   Ни один город не в citySet → не добавляем в результат
//
// Шаг 5: Обрабатываем продавца 4
//   Города: ["Москва", "Казань", "Тула"]
//   Все города в citySet
//   result[4] = ["Москва", "Казань", "Тула"]
//
// Результат: {1: ["Москва"], 2: ["Москва", "Казань"], 4: ["Москва", "Казань", "Тула"]}
//
// Временная сложность: O(s * c + cities)
// - cities: создание citySet - O(cities)
// - s: количество продавцов
// - c: среднее количество городов у продавца
// - Для каждого продавца проходим по его городам: O(s * c)
// - Итого: O(cities + s * c)
//
// В худшем случае: O(n), где n - общее количество городов у всех продавцов
//
// Пространственная сложность: O(cities + s * c)
// - citySet: O(cities)
// - result: в худшем случае O(s * c), если все города совпадают
// - Итого: O(cities + s * c)
//
// Почему используем map вместо slice для поиска?
// - Поиск в slice: O(cities) для каждого города продавца
// - Поиск в map: O(1) для каждого города продавца
// - Для большого количества городов map значительно быстрее
//
// Пример: cities = 1000, у продавца 100 городов
// - С slice: 100 * 1000 = 100,000 операций сравнения
// - С map: 100 * 1 = 100 операций поиска
// - Ускорение в 1000 раз!
