package main

import "fmt"

// ============================================================================
// Решение 1: Префиксные и суффиксные произведения - O(n) время, O(n) память
// ============================================================================

func productExceptSelf(nums []int) []int {
	n := len(nums)
	result := make([]int, n)

	// Вычисляем префиксные произведения
	prefix := make([]int, n)
	prefix[0] = 1
	for i := 1; i < n; i++ {
		prefix[i] = prefix[i-1] * nums[i-1]
	}

	// Вычисляем суффиксные произведения
	suffix := make([]int, n)
	suffix[n-1] = 1
	for i := n - 2; i >= 0; i-- {
		suffix[i] = suffix[i+1] * nums[i+1]
	}

	// Результат = prefix * suffix
	for i := 0; i < n; i++ {
		result[i] = prefix[i] * suffix[i]
	}

	return result
}

// ============================================================================
// Решение 2: Оптимизированное - O(n) время, O(1) память (не считая результат)
// ============================================================================

func productExceptSelfOptimized(nums []int) []int {
	n := len(nums)
	result := make([]int, n)

	// Заполняем result префиксными произведениями
	result[0] = 1
	for i := 1; i < n; i++ {
		result[i] = result[i-1] * nums[i-1]
	}

	// Умножаем на суффиксные произведения
	suffix := 1
	for i := n - 1; i >= 0; i-- {
		result[i] *= suffix
		suffix *= nums[i]
	}

	return result
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение 1: Префикс + Суффикс ===")
	testProductExceptSelf(productExceptSelf)

	fmt.Println("\n=== Решение 2: Оптимизированное ===")
	testProductExceptSelf(productExceptSelfOptimized)

	fmt.Println("\n=== Визуализация процесса ===")
	visualizeProductExceptSelf()
}

func testProductExceptSelf(fn func([]int) []int) {
	testCases := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 2, 3}, []int{6, 3, 2}},
		{[]int{1, 2, 3, 4}, []int{24, 12, 8, 6}},
		{[]int{-1, 1, 0, -3, 3}, []int{0, 0, 9, 0, 0}},
		{[]int{2, 3}, []int{3, 2}},
	}

	for i, tc := range testCases {
		result := fn(tc.input)
		status := "✅"
		for j := 0; j < len(result); j++ {
			if result[j] != tc.expected[j] {
				status = "❌"
				break
			}
		}
		fmt.Printf("%s Тест %d: %v → %v (expected %v)\n",
			status, i+1, tc.input, result, tc.expected)
	}
}

func visualizeProductExceptSelf() {
	nums := []int{1, 2, 3, 4}
	fmt.Printf("Массив: %v\n\n", nums)

	fmt.Println("=== Решение 1: Префикс + Суффикс ===")

	// Префиксные произведения
	prefix := make([]int, len(nums))
	prefix[0] = 1
	fmt.Println("Шаг 1: Вычисляем префиксные произведения")
	fmt.Printf("  prefix[0] = 1\n")
	for i := 1; i < len(nums); i++ {
		prefix[i] = prefix[i-1] * nums[i-1]
		fmt.Printf("  prefix[%d] = prefix[%d] * nums[%d] = %d * %d = %d\n",
			i, i-1, i-1, prefix[i-1], nums[i-1], prefix[i])
	}
	fmt.Printf("  prefix = %v\n\n", prefix)

	// Суффиксные произведения
	suffix := make([]int, len(nums))
	suffix[len(nums)-1] = 1
	fmt.Println("Шаг 2: Вычисляем суффиксные произведения")
	fmt.Printf("  suffix[%d] = 1\n", len(nums)-1)
	for i := len(nums) - 2; i >= 0; i-- {
		suffix[i] = suffix[i+1] * nums[i+1]
		fmt.Printf("  suffix[%d] = suffix[%d] * nums[%d] = %d * %d = %d\n",
			i, i+1, i+1, suffix[i+1], nums[i+1], suffix[i])
	}
	fmt.Printf("  suffix = %v\n\n", suffix)

	// Результат
	fmt.Println("Шаг 3: Умножаем prefix * suffix")
	result := make([]int, len(nums))
	for i := 0; i < len(nums); i++ {
		result[i] = prefix[i] * suffix[i]
		fmt.Printf("  result[%d] = prefix[%d] * suffix[%d] = %d * %d = %d\n",
			i, i, i, prefix[i], suffix[i], result[i])
	}
	fmt.Printf("  result = %v\n\n", result)

	fmt.Println("=== Решение 2: Оптимизированное ===")
	fmt.Println("(Используем result для хранения prefix, затем умножаем на suffix)")
}

// ============================================================================
// Объяснение решений
// ============================================================================

// РЕШЕНИЕ 1: Префиксные и суффиксные произведения
//
// ============================================================================
// ВЫСОКОУРОВНЕВАЯ ИДЕЯ
// ============================================================================
//
// Задача: Для каждого элемента nums[i] вычислить произведение всех элементов,
// кроме nums[i], БЕЗ использования деления.
//
// Ключевая идея:
// - Произведение всех кроме nums[i] = произведение слева × произведение справа
// - Префикс: произведение всех элементов до i (не включая i)
// - Суффикс: произведение всех элементов после i (не включая i)
// - Результат[i] = prefix[i] × suffix[i]
//
// Почему это работает?
// - Для nums[i] нужно: nums[0] × nums[1] × ... × nums[i-1] × nums[i+1] × ... × nums[n-1]
// - Это можно разбить на:
//   - prefix[i] = nums[0] × nums[1] × ... × nums[i-1]
//   - suffix[i] = nums[i+1] × ... × nums[n-1]
// - Результат = prefix[i] × suffix[i]
//
// Алгоритм:
// 1. Вычислить prefix[i] = произведение всех элементов слева от i
// 2. Вычислить suffix[i] = произведение всех элементов справа от i
// 3. Для каждого i: result[i] = prefix[i] × suffix[i]
//
// ============================================================================
// ДЕТАЛЬНЫЙ РАЗБОР КОДА
// ============================================================================
//
// func productExceptSelf(nums []int) []int {
//     n := len(nums)
//     result := make([]int, n)
//
// СТРОКИ 1-3: Инициализация
// - n: длина массива
// - result: массив для результата размером n
//
//     // Вычисляем префиксные произведения
//     prefix := make([]int, n)
//     prefix[0] = 1
//
// СТРОКИ 4-6: Создание массива префиксов
// - prefix[i] будет содержать произведение всех элементов слева от i
// - prefix[0] = 1 (нет элементов слева от 0-го элемента)
// - Почему 1? Потому что 1 — нейтральный элемент для умножения
//
//     for i := 1; i < n; i++ {
//         prefix[i] = prefix[i-1] * nums[i-1]
//     }
//
// СТРОКИ 7-9: Вычисление префиксов
// - Начинаем с i=1 (для i=0 уже установлено)
// - prefix[i] = произведение всех элементов от 0 до i-1
// - Используем предыдущее значение: prefix[i] = prefix[i-1] × nums[i-1]
//
// МАТЕМАТИКА:
// prefix[i] = nums[0] × nums[1] × ... × nums[i-1]
// prefix[i-1] = nums[0] × nums[1] × ... × nums[i-2]
// prefix[i] = prefix[i-1] × nums[i-1] ✓
//
// ПРИМЕР: nums = [1, 2, 3, 4]
// prefix[0] = 1
// prefix[1] = prefix[0] × nums[0] = 1 × 1 = 1
// prefix[2] = prefix[1] × nums[1] = 1 × 2 = 2
// prefix[3] = prefix[2] × nums[2] = 2 × 3 = 6
// prefix = [1, 1, 2, 6]
//
//     // Вычисляем суффиксные произведения
//     suffix := make([]int, n)
//     suffix[n-1] = 1
//
// СТРОКИ 10-12: Создание массива суффиксов
// - suffix[i] будет содержать произведение всех элементов справа от i
// - suffix[n-1] = 1 (нет элементов справа от последнего элемента)
// - Почему 1? Аналогично префиксу — нейтральный элемент
//
//     for i := n - 2; i >= 0; i-- {
//         suffix[i] = suffix[i+1] * nums[i+1]
//     }
//
// СТРОКИ 13-15: Вычисление суффиксов
// - Идем справа налево (от n-2 до 0)
// - suffix[i] = произведение всех элементов от i+1 до n-1
// - Используем следующее значение: suffix[i] = suffix[i+1] × nums[i+1]
//
// МАТЕМАТИКА:
// suffix[i] = nums[i+1] × nums[i+2] × ... × nums[n-1]
// suffix[i+1] = nums[i+2] × ... × nums[n-1]
// suffix[i] = nums[i+1] × suffix[i+1] ✓
//
// ПРИМЕР: nums = [1, 2, 3, 4]
// suffix[3] = 1
// suffix[2] = suffix[3] × nums[3] = 1 × 4 = 4
// suffix[1] = suffix[2] × nums[2] = 4 × 3 = 12
// suffix[0] = suffix[1] × nums[1] = 12 × 2 = 24
// suffix = [24, 12, 4, 1]
//
//     // Результат = prefix * suffix
//     for i := 0; i < n; i++ {
//         result[i] = prefix[i] * suffix[i]
//     }
//
// СТРОКИ 16-19: Вычисление результата
// - Для каждого индекса умножаем prefix[i] на suffix[i]
// - Это дает произведение всех элементов кроме nums[i]
//
// ПРИМЕР: nums = [1, 2, 3, 4]
// prefix = [1, 1, 2, 6]
// suffix = [24, 12, 4, 1]
//
// result[0] = prefix[0] × suffix[0] = 1 × 24 = 24
//   Проверка: 2 × 3 × 4 = 24 ✓
//
// result[1] = prefix[1] × suffix[1] = 1 × 12 = 12
//   Проверка: 1 × 3 × 4 = 12 ✓
//
// result[2] = prefix[2] × suffix[2] = 2 × 4 = 8
//   Проверка: 1 × 2 × 4 = 8 ✓
//
// result[3] = prefix[3] × suffix[3] = 6 × 1 = 6
//   Проверка: 1 × 2 × 3 = 6 ✓
//
// result = [24, 12, 8, 6] ✓
//
//     return result
// }
//
// ============================================================================
// ВИЗУАЛИЗАЦИЯ
// ============================================================================
//
// nums = [1, 2, 3]
//
// ПРЕФИКСЫ (произведение слева):
// i=0: нет элементов слева → prefix[0] = 1
// i=1: элементы слева = [1] → prefix[1] = 1
// i=2: элементы слева = [1,2] → prefix[2] = 1×2 = 2
// prefix = [1, 1, 2]
//
// СУФФИКСЫ (произведение справа):
// i=0: элементы справа = [2,3] → suffix[0] = 2×3 = 6
// i=1: элементы справа = [3] → suffix[1] = 3
// i=2: нет элементов справа → suffix[2] = 1
// suffix = [6, 3, 1]
//
// РЕЗУЛЬТАТ:
// result[0] = prefix[0] × suffix[0] = 1 × 6 = 6  (2×3)
// result[1] = prefix[1] × suffix[1] = 1 × 3 = 3  (1×3)
// result[2] = prefix[2] × suffix[2] = 2 × 1 = 2  (1×2)
// result = [6, 3, 2] ✓
//
// ============================================================================
// СЛОЖНОСТЬ
// ============================================================================
//
// Временная сложность: O(n)
// - Вычисление prefix: один проход, n-1 итераций → O(n)
// - Вычисление suffix: один проход, n-1 итераций → O(n)
// - Вычисление result: один проход, n итераций → O(n)
// - Итого: O(n) + O(n) + O(n) = O(3n) = O(n)
//
// Пространственная сложность: O(n)
// - Массив prefix: n элементов → O(n)
// - Массив suffix: n элементов → O(n)
// - Массив result: n элементов → O(n)
// - Итого: O(n) + O(n) + O(n) = O(3n) = O(n)
//
// МОЖНО ЛИ УЛУЧШИТЬ ПАМЯТЬ?
// - Да! Можно использовать result для хранения prefix
// - Суффикс вычислять на лету
// - Это дает O(1) дополнительной памяти (см. Решение 2)
//
// ============================================================================
// РЕШЕНИЕ 2: Оптимизированное (O(1) дополнительной памяти)
// ============================================================================
//
// ============================================================================
// ВЫСОКОУРОВНЕВАЯ ИДЕЯ
// ============================================================================
//
// Оптимизация:
// - Используем result для хранения prefix (вместо отдельного массива)
// - Суффикс вычисляем на лету, умножая на result
// - Экономим O(n) памяти
//
// Алгоритм:
// 1. Заполняем result префиксными произведениями (как в Решении 1)
// 2. Идем справа налево, умножая result на суффикс
// 3. Суффикс вычисляем на лету, не храня массив
//
// ============================================================================
// ДЕТАЛЬНЫЙ РАЗБОР КОДА
// ============================================================================
//
// func productExceptSelfOptimized(nums []int) []int {
//     n := len(nums)
//     result := make([]int, n)
//
// СТРОКИ 1-3: Инициализация
// - Аналогично Решению 1
//
//     // Заполняем result префиксными произведениями
//     result[0] = 1
//     for i := 1; i < n; i++ {
//         result[i] = result[i-1] * nums[i-1]
//     }
//
// СТРОКИ 4-7: Вычисление префиксов в result
// - Вместо отдельного массива prefix используем result
// - result[i] теперь содержит prefix[i]
// - Экономим память!
//
// ПРИМЕР: nums = [1, 2, 3, 4]
// result[0] = 1
// result[1] = result[0] × nums[0] = 1 × 1 = 1
// result[2] = result[1] × nums[1] = 1 × 2 = 2
// result[3] = result[2] × nums[2] = 2 × 3 = 6
// После этого цикла: result = [1, 1, 2, 6] (это prefix!)
//
//     // Умножаем на суффиксные произведения
//     suffix := 1
//     for i := n - 1; i >= 0; i-- {
//         result[i] *= suffix
//         suffix *= nums[i]
//     }
//
// СТРОКИ 8-12: Умножение на суффикс
// - Идем справа налево
// - suffix: текущее произведение элементов справа от i
// - Умножаем result[i] (который содержит prefix[i]) на suffix
// - Обновляем suffix для следующей итерации
//
// КЛЮЧЕВОЙ МОМЕНТ: Порядок операций важен!
// 1. Сначала умножаем result[i] на suffix (текущий суффикс)
// 2. Затем обновляем suffix = suffix × nums[i] (для следующей итерации)
//
// Почему такой порядок?
// - На итерации i нам нужен суффикс для i (элементы справа от i)
// - После умножения обновляем suffix, чтобы на следующей итерации (i-1)
//   он содержал произведение элементов справа от i-1
//
// ПРИМЕР: nums = [1, 2, 3, 4], result = [1, 1, 2, 6] (prefix)
//
// Итерация i=3:
//   result[3] = result[3] × suffix = 6 × 1 = 6
//   suffix = suffix × nums[3] = 1 × 4 = 4
//   result = [1, 1, 2, 6], suffix = 4
//
// Итерация i=2:
//   result[2] = result[2] × suffix = 2 × 4 = 8
//   suffix = suffix × nums[2] = 4 × 3 = 12
//   result = [1, 1, 8, 6], suffix = 12
//
// Итерация i=1:
//   result[1] = result[1] × suffix = 1 × 12 = 12
//   suffix = suffix × nums[1] = 12 × 2 = 24
//   result = [1, 12, 8, 6], suffix = 24
//
// Итерация i=0:
//   result[0] = result[0] × suffix = 1 × 24 = 24
//   suffix = suffix × nums[0] = 24 × 1 = 24
//   result = [24, 12, 8, 6], suffix = 24
//
// Результат: [24, 12, 8, 6] ✓
//
//     return result
// }
//
// ============================================================================
// ВИЗУАЛИЗАЦИЯ ОПТИМИЗИРОВАННОГО РЕШЕНИЯ
// ============================================================================
//
// nums = [1, 2, 3]
//
// ШАГ 1: Заполняем result префиксами
// result[0] = 1
// result[1] = 1 × 1 = 1
// result[2] = 1 × 2 = 2
// result = [1, 1, 2] (это prefix!)
//
// ШАГ 2: Умножаем на суффикс справа налево
// i=2: result[2] = 2 × 1 = 2, suffix = 1 × 3 = 3
// i=1: result[1] = 1 × 3 = 3, suffix = 3 × 2 = 6
// i=0: result[0] = 1 × 6 = 6, suffix = 6 × 1 = 6
// result = [6, 3, 2] ✓
//
// ============================================================================
// СЛОЖНОСТЬ ОПТИМИЗИРОВАННОГО РЕШЕНИЯ
// ============================================================================
//
// Временная сложность: O(n)
// - Первый цикл (префиксы): O(n)
// - Второй цикл (суффиксы): O(n)
// - Итого: O(n)
//
// Пространственная сложность: O(1) дополнительной памяти
// - result: O(n) — но это выходной массив, не считается
// - suffix: O(1) — одна переменная
// - Дополнительная память: O(1)
//
// ПОЧЕМУ O(1), а не O(n)?
// - В Big O анализе не считаем память для выходных данных
// - result — это результат функции, не промежуточная структура
// - Аналогия: если функция возвращает массив, мы не считаем его в памяти
//
// ============================================================================
// CORNER CASES
// ============================================================================
//
// CASE 1: Массив из двух элементов
// Input: nums = [2, 3]
// Ожидаем: [3, 2]
//
// Решение 1:
// prefix = [1, 2]
// suffix = [3, 1]
// result = [1×3, 2×1] = [3, 2] ✓
//
// Решение 2:
// result = [1, 2] (prefix)
// i=1: result[1] = 2×1 = 2, suffix = 1×3 = 3
// i=0: result[0] = 1×3 = 3, suffix = 3×2 = 6
// result = [3, 2] ✓
//
// ============================================================================
//
// CASE 2: Массив с нулями
// Input: nums = [-1, 1, 0, -3, 3]
// Ожидаем: [0, 0, 9, 0, 0]
//
// Решение 1:
// prefix = [1, -1, -1, 0, 0]
// suffix = [0, 0, -9, -3, 1]
// result = [0, 0, 9, 0, 0] ✓
//
// ОСОБЕННОСТЬ:
// - Если nums[i] = 0, то result[i] = произведение всех остальных
// - Если есть один ноль, все остальные result будут 0
// - Если есть два нуля, все result будут 0
//
// ============================================================================
//
// CASE 3: Массив с отрицательными числами
// Input: nums = [-1, -2, -3]
// Ожидаем: [6, 3, 2]
//
// Решение работает корректно:
// prefix = [1, -1, 2]
// suffix = [6, -3, 1]
// result = [6, 3, 2] ✓
//
// ============================================================================
//
// CASE 4: Один элемент
// Input: nums = [5]
// Ожидаем: [1] (произведение пустого множества = 1)
//
// Решение:
// prefix = [1]
// suffix = [1]
// result = [1] ✓
//
// ============================================================================
// СРАВНЕНИЕ РЕШЕНИЙ
// ============================================================================
//
// Критерий          | Решение 1      | Решение 2
// ------------------|----------------|----------------
// Время             | O(n)           | O(n)
// Доп. память       | O(n)           | O(1)
// Читаемость        | ★★★★★          | ★★★★
// Простота          | ★★★★★          | ★★★
// Эффективность     | ★★★★           | ★★★★★
//
// РЕКОМЕНДАЦИЯ:
// - Решение 1: проще понять, использовать для обучения
// - Решение 2: использовать в production (экономия памяти)
//
// ============================================================================
// ПОЧЕМУ НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ ДЕЛЕНИЕ?
// ============================================================================
//
// Наивное решение с делением:
// total := 1
// for _, num := range nums {
//     total *= num
// }
// for i := range nums {
//     result[i] = total / nums[i]
// }
//
// ПРОБЛЕМЫ:
// 1. ДЕЛЕНИЕ НА НОЛЬ
//    Если nums[i] = 0 → деление на 0 → panic!
//
// 2. ПОТЕРЯ ТОЧНОСТИ
//    При работе с целыми числами деление может дать нецелый результат
//    Но в Go int деление целочисленное, так что это не проблема
//
// 3. ТРЕБОВАНИЕ ЗАДАЧИ
//    Явно указано: "без использования деления"
//    Возможно, для обучения технике префиксных/суффиксных массивов
//
// 4. ПРОИЗВЕДЕНИЕ МОЖЕТ ПЕРЕПОЛНИТЬСЯ
//    total может быть очень большим числом
//    Но это проблема и для нашего решения тоже
//
// ============================================================================
// ПРИМЕНЕНИЕ В РЕАЛЬНЫХ ЗАДАЧАХ
// ============================================================================
//
// 1. СТАТИСТИКА
//    - Вычисление среднего без одного элемента
//    - Анализ влияния выбросов
//
// 2. МАТЕМАТИЧЕСКИЕ ВЫЧИСЛЕНИЯ
//    - Вычисление производных
//    - Полиномиальные вычисления
//
// 3. ОБРАБОТКА СИГНАЛОВ
//    - Фильтрация с исключением одного отсчета
//    - Анализ временных рядов
//
// 4. МАШИННОЕ ОБУЧЕНИЕ
//    - Leave-one-out cross-validation
//    - Вычисление метрик без одного образца
//
// ============================================================================
