package main

import "fmt"

// ============================================================================
// Решение: Использование массива как hash set (in-place)
// ============================================================================

func findDisappearedNumbers(nums []int) []int {
	// Используем сам массив nums как hash set
	// Для каждого числа nums[i] помечаем индекс abs(nums[i])-1 как отрицательный
	// Это означает, что число abs(nums[i]) присутствует в массиве

	for i := 0; i < len(nums); i++ {
		// Берем абсолютное значение, так как мы можем изменить знак
		index := abs(nums[i]) - 1
		// Помечаем индекс как посещенный (делаем отрицательным)
		if nums[index] > 0 {
			nums[index] = -nums[index]
		}
	}

	// Находим все положительные индексы - это пропущенные числа
	var result []int
	for i := 0; i < len(nums); i++ {
		if nums[i] > 0 {
			result = append(result, i+1)
		}
	}

	return result
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение: Find All Numbers Disappeared ===")
	testFindDisappearedNumbers()
}

func testFindDisappearedNumbers() {
	// Тест 1
	nums1 := []int{4, 3, 2, 7, 8, 2, 3, 1}
	result1 := findDisappearedNumbers(nums1)
	fmt.Printf("Тест 1: %v (ожидается [5, 6])\n", result1)

	// Тест 2
	nums2 := []int{1, 1}
	result2 := findDisappearedNumbers(nums2)
	fmt.Printf("Тест 2: %v (ожидается [2])\n", result2)
}

// ============================================================================
// Объяснение решения
// ============================================================================

// РЕШЕНИЕ: Использование массива как hash set (in-place)
//
// Идея:
// - Используем сам массив nums как hash set без дополнительной памяти
// - Для каждого числа nums[i] помечаем индекс abs(nums[i])-1 как отрицательный
// - Это означает, что число abs(nums[i]) присутствует в массиве
// - После обработки все положительные индексы соответствуют пропущенным числам
//
// Алгоритм:
// 1. Проходим по массиву nums
// 2. Для каждого числа nums[i]:
//    - Вычисляем индекс: index = abs(nums[i]) - 1
//    - Если nums[index] > 0, делаем его отрицательным (помечаем как посещенный)
// 3. Проходим по массиву второй раз
// 4. Все положительные элементы соответствуют пропущенным числам
//
// Пример работы:
// nums = [4, 3, 2, 7, 8, 2, 3, 1]
// Индексы: 0  1  2  3  4  5  6  7
//
// Итерация 1: i=0, nums[0]=4
//   index = abs(4) - 1 = 3
//   nums[3] = 7 > 0 → nums[3] = -7
//   nums = [4, 3, 2, -7, 8, 2, 3, 1]
//
// Итерация 2: i=1, nums[1]=3
//   index = abs(3) - 1 = 2
//   nums[2] = 2 > 0 → nums[2] = -2
//   nums = [4, 3, -2, -7, 8, 2, 3, 1]
//
// Итерация 3: i=2, nums[2]=-2
//   index = abs(-2) - 1 = 1
//   nums[1] = 3 > 0 → nums[1] = -3
//   nums = [4, -3, -2, -7, 8, 2, 3, 1]
//
// Итерация 4: i=3, nums[3]=-7
//   index = abs(-7) - 1 = 6
//   nums[6] = 3 > 0 → nums[6] = -3
//   nums = [4, -3, -2, -7, 8, 2, -3, 1]
//
// Итерация 5: i=4, nums[4]=8
//   index = abs(8) - 1 = 7
//   nums[7] = 1 > 0 → nums[7] = -1
//   nums = [4, -3, -2, -7, 8, 2, -3, -1]
//
// Итерация 6: i=5, nums[5]=2
//   index = abs(2) - 1 = 1
//   nums[1] = -3 < 0 → уже помечен, пропускаем
//   nums = [4, -3, -2, -7, 8, 2, -3, -1]
//
// Итерация 7: i=6, nums[6]=-3
//   index = abs(-3) - 1 = 2
//   nums[2] = -2 < 0 → уже помечен, пропускаем
//   nums = [4, -3, -2, -7, 8, 2, -3, -1]
//
// Итерация 8: i=7, nums[7]=-1
//   index = abs(-1) - 1 = 0
//   nums[0] = 4 > 0 → nums[0] = -4
//   nums = [-4, -3, -2, -7, 8, 2, -3, -1]
//
// После первого прохода:
// nums = [-4, -3, -2, -7, 8, 2, -3, -1]
//         0   1   2   3  4  5   6   7
//
// Второй проход: находим положительные элементы
//   nums[4] = 8 > 0 → пропущено число 5 (индекс 4 → число 5)
//   nums[5] = 2 > 0 → пропущено число 6 (индекс 5 → число 6)
//
// Результат: [5, 6]
//
// Временная сложность: O(n)
// - Первый проход: O(n) - проходим по всем элементам
// - Второй проход: O(n) - проходим по всем элементам
// - Итого: O(n)
//
// Пространственная сложность: O(1) дополнительной памяти
// - Используем сам массив nums для хранения информации
// - Только переменные: O(1)
// - Результат не считается дополнительной памятью (по условию задачи)
// - Итого: O(1) дополнительной памяти
//
// Почему это работает?
// - Каждое число nums[i] в диапазоне [1, n]
// - Индекс abs(nums[i])-1 всегда валидный (от 0 до n-1)
// - Делая элемент отрицательным, мы помечаем, что число присутствует
// - Положительные элементы после обработки = пропущенные числа
//
// Почему abs()?
// - Мы можем изменить знак элемента на отрицательный
// - При обработке следующего элемента нужно знать исходное значение
// - abs() восстанавливает исходное значение для вычисления индекса
//
// Альтернативное решение (с дополнительной памятью):
// func findDisappearedNumbers(nums []int) []int {
//     seen := make(map[int]bool)
//     for _, num := range nums {
//         seen[num] = true
//     }
//     var result []int
//     for i := 1; i <= len(nums); i++ {
//         if !seen[i] {
//             result = append(result, i)
//         }
//     }
//     return result
// }
// - Проще понять, но требует O(n) дополнительной памяти
// - Для собеседований in-place решение показывает умение оптимизировать память
