package main

import "fmt"

// ============================================================================
// Решение: Слияние с конца (оптимальное)
// ============================================================================

func merge(arr1 []int, m int, arr2 []int, n int) {
	// Указатели на последние элементы в arr1 и arr2
	i := m - 1     // последний элемент в arr1
	j := n - 1     // последний элемент в arr2
	k := m + n - 1 // последняя позиция в результате

	// Идем с конца, сравниваем и помещаем больший элемент в конец arr1
	for i >= 0 && j >= 0 {
		if arr1[i] > arr2[j] {
			arr1[k] = arr1[i]
			i--
		} else {
			arr1[k] = arr2[j]
			j--
		}
		k--
	}

	// Если остались элементы в arr2, копируем их
	// (элементы из arr1 уже на своих местах)
	for j >= 0 {
		arr1[k] = arr2[j]
		j--
		k--
	}
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение 1: Слияние с конца ===")
	testMerge(merge)

	fmt.Println("\n=== Визуализация процесса слияния ===")
	visualizeMerge()
}

func testMerge(mergeFn func([]int, int, []int, int)) {
	testCases := []struct {
		arr1     []int
		m        int
		arr2     []int
		n        int
		expected []int
	}{
		{
			arr1:     []int{1, 3, 5, 7, 0, 0, 0, 0},
			m:        4,
			arr2:     []int{2, 4, 6, 8},
			n:        4,
			expected: []int{1, 2, 3, 4, 5, 6, 7, 8},
		},
		{
			arr1:     []int{1, 2, 3, 0, 0, 0},
			m:        3,
			arr2:     []int{2, 5, 6},
			n:        3,
			expected: []int{1, 2, 2, 3, 5, 6},
		},
		{
			arr1:     []int{0},
			m:        0,
			arr2:     []int{1},
			n:        1,
			expected: []int{1},
		},
		{
			arr1:     []int{1, 0},
			m:        1,
			arr2:     []int{2},
			n:        1,
			expected: []int{1, 2},
		},
		{
			arr1:     []int{4, 5, 6, 0, 0, 0},
			m:        3,
			arr2:     []int{1, 2, 3},
			n:        3,
			expected: []int{1, 2, 3, 4, 5, 6},
		},
	}

	for i, tc := range testCases {
		// Копируем массивы для теста
		arr1Copy := make([]int, len(tc.arr1))
		copy(arr1Copy, tc.arr1)

		mergeFn(arr1Copy, tc.m, tc.arr2, tc.n)

		// Проверяем результат
		status := "✅"
		for j := 0; j < len(tc.expected); j++ {
			if arr1Copy[j] != tc.expected[j] {
				status = "❌"
				break
			}
		}

		fmt.Printf("%s Тест %d: arr1=%v, arr2=%v → %v\n",
			status, i+1, tc.arr1[:tc.m], tc.arr2, arr1Copy)
	}
}

func visualizeMerge() {
	arr1 := []int{1, 3, 5, 7, 0, 0, 0, 0}
	arr2 := []int{2, 4, 6, 8}
	m, n := 4, 4

	fmt.Printf("Начальное состояние:\n")
	fmt.Printf("arr1 = %v (m=%d элементов + %d нулей)\n", arr1, m, n)
	fmt.Printf("arr2 = %v (n=%d элементов)\n\n", arr2, n)

	i := m - 1
	j := n - 1
	k := m + n - 1

	step := 1

	for i >= 0 && j >= 0 {
		fmt.Printf("Шаг %d:\n", step)
		fmt.Printf("  Сравниваем arr1[%d]=%d и arr2[%d]=%d\n", i, arr1[i], j, arr2[j])

		if arr1[i] > arr2[j] {
			fmt.Printf("  arr1[%d]=%d > arr2[%d]=%d → помещаем %d на позицию %d\n",
				i, arr1[i], j, arr2[j], arr1[i], k)
			arr1[k] = arr1[i]
			i--
		} else {
			fmt.Printf("  arr1[%d]=%d <= arr2[%d]=%d → помещаем %d на позицию %d\n",
				i, arr1[i], j, arr2[j], arr2[j], k)
			arr1[k] = arr2[j]
			j--
		}
		k--

		fmt.Printf("  arr1 = %v\n\n", arr1)
		step++
	}

	for j >= 0 {
		fmt.Printf("Шаг %d: копируем оставшиеся из arr2[%d]=%d на позицию %d\n",
			step, j, arr2[j], k)
		arr1[k] = arr2[j]
		j--
		k--
		fmt.Printf("  arr1 = %v\n\n", arr1)
		step++
	}

	fmt.Printf("Результат: %v\n", arr1)
}

// ============================================================================
// Объяснение решений
// ============================================================================

// РЕШЕНИЕ: Слияние с конца (ОПТИМАЛЬНОЕ)
//
// Идея:
// - Массив arr1 имеет достаточно места в конце для всех элементов
// - Начинаем слияние с конца массивов, идя к началу
// - Помещаем больший элемент в конец arr1
// - Таким образом избегаем перезаписи еще не обработанных элементов arr1
//
// Визуализация:
// arr1 = [1, 3, 5, 7, _, _, _, _]  (m=4)
// arr2 = [2, 4, 6, 8]               (n=4)
//
// i=3, j=3, k=7: arr1[3]=7 > arr2[3]=8? Нет → arr1[7]=8
// arr1 = [1, 3, 5, 7, _, _, _, 8]
//
// i=3, j=2, k=6: arr1[3]=7 > arr2[2]=6? Да → arr1[6]=7
// arr1 = [1, 3, 5, 7, _, _, 7, 8]
//
// i=2, j=2, k=5: arr1[2]=5 > arr2[2]=6? Нет → arr1[5]=6
// arr1 = [1, 3, 5, 7, _, 6, 7, 8]
//
// i=2, j=1, k=4: arr1[2]=5 > arr2[1]=4? Да → arr1[4]=5
// arr1 = [1, 3, 5, 7, 5, 6, 7, 8]
//
// i=1, j=1, k=3: arr1[1]=3 > arr2[1]=4? Нет → arr1[3]=4
// arr1 = [1, 3, 5, 4, 5, 6, 7, 8]
//
// i=1, j=0, k=2: arr1[1]=3 > arr2[0]=2? Да → arr1[2]=3
// arr1 = [1, 3, 3, 4, 5, 6, 7, 8]
//
// i=0, j=0, k=1: arr1[0]=1 > arr2[0]=2? Нет → arr1[1]=2
// arr1 = [1, 2, 3, 4, 5, 6, 7, 8]
//
// i=0, j=-1, k=0: j < 0, копируем arr1[0]=1 на arr1[0]=1
// Готово!
//
// Временная сложность: O(m + n)
// - Проходим каждый элемент ровно один раз
// - m элементов из arr1 и n элементов из arr2
// - Всего m + n операций
//
// Пространственная сложность: O(1)
// - Используем только 3 переменных (i, j, k)
// - Не создаем дополнительных массивов
// - Все операции выполняются in-place
//
// Почему O(1) по памяти?
// - Не зависит от размера входных данных
// - Фиксированное количество переменных
//
// Плюсы:
// - Оптимальная сложность
// - Минимальное использование памяти
// - Элегантное решение
// - Один проход по данным
//
// Минусы:
// - Требует понимания, почему начинаем с конца
// - Менее интуитивно, чем слияние с начала
//
// ============================================================================
// ПОЧЕМУ НАЧИНАЕМ С КОНЦА?
//
// Проблема начала с начала:
// arr1 = [1, 3, 5, 7, _, _, _, _]
// arr2 = [2, 4, 6, 8]
//
// Если начнем с начала:
// - arr1[0]=1 < arr2[0]=2, оставляем arr1[0]=1
// - arr1[1]=3 > arr2[0]=2, нужно вставить 2
// - Но куда? На место arr1[1] перезапишем 3!
// - Придется сдвигать все элементы → O(n) на каждую вставку → O(n²)
//
// Решение — начать с конца:
// - В конце arr1 есть свободное место
// - Помещаем туда максимальные элементы
// - Не перезаписываем еще не обработанные данные
// - Избегаем сдвигов
//
// ============================================================================

// CORNER CASES
//
// 1. arr1 пустой (m=0):
//    arr1 = [0, 0, 0], arr2 = [1, 2, 3]
//    Цикл for i >= 0 && j >= 0 не выполнится
//    Второй цикл скопирует все элементы arr2
//
// 2. arr2 пустой (n=0):
//    arr1 = [1, 2, 3], arr2 = []
//    Ничего не нужно делать, arr1 уже отсортирован
//
// 3. Все элементы arr1 меньше arr2:
//    arr1 = [1, 2, 3, _, _, _], arr2 = [4, 5, 6]
//    Первый цикл скопирует все arr1 элементы
//    Второй цикл скопирует все arr2 элементы
//
// 4. Все элементы arr2 меньше arr1:
//    arr1 = [4, 5, 6, _, _, _], arr2 = [1, 2, 3]
//    Сначала обработаем все arr1
//    Потом скопируем все arr2
//
// 5. Дубликаты:
//    arr1 = [1, 2, 3, _, _, _], arr2 = [2, 2, 2]
//    Алгоритм корректно обработает, используя arr1[i] > arr2[j]
//    (не >=, поэтому стабильная сортировка)
//
// ============================================================================

// СВЯЗЬ С MERGE SORT
//
// Эта задача — ключевая часть алгоритма Merge Sort:
//
// func mergeSort(arr []int) []int {
//     if len(arr) <= 1 {
//         return arr
//     }
//     mid := len(arr) / 2
//     left := mergeSort(arr[:mid])
//     right := mergeSort(arr[mid:])
//     return merge(left, right)  // ← используем эту функцию
// }
//
// Merge Sort:
// - Временная сложность: O(n log n)
// - Пространственная сложность: O(n)
// - Стабильная сортировка
// - Гарантированная O(n log n) даже в худшем случае
//
// ============================================================================










