package main

import "fmt"

// ============================================================================
// Решение: Два указателя (two pointers) - оптимальное
// ============================================================================

func remove(in []int) []int {
	j := 0 // указатель на позицию для записи ненулевого элемента

	// i - указатель для чтения
	for i := 0; i < len(in); i++ {
		if in[i] != 0 {
			in[j] = in[i]
			j++
		}
	}

	return in[:j]
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение 1: Два указателя ===")
	testRemove(remove)

	fmt.Println("\n=== Визуализация процесса ===")
	visualizeRemoval()
}

func testRemove(removeFn func([]int) []int) {
	testCases := []struct {
		input    []int
		expected []int
	}{
		{[]int{}, []int{}},
		{[]int{0}, []int{}},
		{[]int{1, 0, 0, 2}, []int{1, 2}},
		{[]int{0, 0, 1, 2, 3}, []int{1, 2, 3}},
		{[]int{1, 2, 3}, []int{1, 2, 3}},
		{[]int{0, 0, 0}, []int{}},
		{[]int{1, 0, 2, 0, 3, 0}, []int{1, 2, 3}},
	}

	for i, tc := range testCases {
		// Копируем входной массив для теста
		input := make([]int, len(tc.input))
		copy(input, tc.input)

		result := removeFn(input)

		status := "✅"
		if len(result) != len(tc.expected) {
			status = "❌"
		} else {
			for j := 0; j < len(result); j++ {
				if result[j] != tc.expected[j] {
					status = "❌"
					break
				}
			}
		}

		fmt.Printf("%s Тест %d: %v → %v (ожидалось %v)\n",
			status, i+1, tc.input, result, tc.expected)
	}
}

func visualizeRemoval() {
	arr := []int{1, 0, 0, 2, 3, 0, 4}
	fmt.Printf("Исходный массив: %v\n\n", arr)

	j := 0

	for i := 0; i < len(arr); i++ {
		fmt.Printf("Шаг %d:\n", i+1)
		fmt.Printf("  i=%d, j=%d, arr[i]=%d\n", i, j, arr[i])

		if arr[i] != 0 {
			fmt.Printf("  arr[i] != 0 → копируем arr[%d]=%d в arr[%d]\n", i, arr[i], j)
			arr[j] = arr[i]
			j++
		} else {
			fmt.Printf("  arr[i] == 0 → пропускаем\n")
		}

		// Показываем состояние массива
		fmt.Printf("  Массив: [")
		for k := 0; k < len(arr); k++ {
			if k == j && k <= i {
				fmt.Printf("*%d", arr[k])
			} else {
				fmt.Printf("%d", arr[k])
			}
			if k < len(arr)-1 {
				fmt.Print(", ")
			}
		}
		fmt.Printf("] (* - позиция j)\n\n")
	}

	result := arr[:j]
	fmt.Printf("Результат: %v (arr[:j] = arr[:%d])\n", result, j)
}

// ============================================================================
// Объяснение решений
// ============================================================================

// РЕШЕНИЕ: Два указателя (ОПТИМАЛЬНОЕ)
//
// Идея:
// - Используем два указателя: i (чтение) и j (запись)
// - i проходит по всем элементам
// - j указывает на позицию, куда записать следующий ненулевой элемент
// - Когда встречаем ненулевой элемент, копируем его на позицию j и увеличиваем j
// - Нули просто пропускаем
//
// Визуализация:
// Исходный: [1, 0, 0, 2, 3, 0, 4]
//
// i=0, j=0: arr[0]=1 → arr[0]=1, j=1
// [1, 0, 0, 2, 3, 0, 4]
//  ^j
//
// i=1, j=1: arr[1]=0 → пропускаем
// [1, 0, 0, 2, 3, 0, 4]
//     ^j
//
// i=2, j=1: arr[2]=0 → пропускаем
// [1, 0, 0, 2, 3, 0, 4]
//     ^j
//
// i=3, j=1: arr[3]=2 → arr[1]=2, j=2
// [1, 2, 0, 2, 3, 0, 4]
//        ^j
//
// i=4, j=2: arr[4]=3 → arr[2]=3, j=3
// [1, 2, 3, 2, 3, 0, 4]
//           ^j
//
// i=5, j=3: arr[5]=0 → пропускаем
// [1, 2, 3, 2, 3, 0, 4]
//           ^j
//
// i=6, j=3: arr[6]=4 → arr[3]=4, j=4
// [1, 2, 3, 4, 3, 0, 4]
//              ^j
//
// Результат: arr[:4] = [1, 2, 3, 4]
//
// Временная сложность: O(n)
// - Проходим по массиву ровно один раз
// - n итераций цикла for
// - Каждая итерация: O(1) операций (сравнение, присваивание, инкремент)
// - Итого: O(n)
//
// Пространственная сложность: O(1)
// - Используем только две переменных (i, j)
// - Не создаем дополнительных структур данных
// - Все операции выполняются in-place
// - Память не зависит от размера входных данных
//
// Почему O(1)?
// - Переменные i, j занимают константную память
// - Слайс in[:j] не создает копию, а просто меняет границы
// - Фиксированное количество переменных
//
// Плюсы:
// - Оптимальная сложность O(n) времени, O(1) памяти
// - Один проход по массиву
// - Минимальное использование памяти
// - In-place модификация
// - Сохраняет порядок элементов
//
// Минусы:
// - Изменяет исходный массив (но это требование задачи)
//
// ============================================================================
// ПРИМЕНЕНИЕ ТЕХНИКИ ДВУХ УКАЗАТЕЛЕЙ
//
// Этот алгоритм — частный случай partition (разделения).
// Используется во многих задачах:
//
// 1. УДАЛЕНИЕ ДУБЛИКАТОВ
//    func removeDuplicates(arr []int) []int {
//        if len(arr) == 0 { return arr }
//        j := 1
//        for i := 1; i < len(arr); i++ {
//            if arr[i] != arr[i-1] {
//                arr[j] = arr[i]
//                j++
//            }
//        }
//        return arr[:j]
//    }
//
// 2. PARTITION В QUICKSORT
//    func partition(arr []int, pivot int) int {
//        j := 0
//        for i := 0; i < len(arr); i++ {
//            if arr[i] < pivot {
//                arr[i], arr[j] = arr[j], arr[i]
//                j++
//            }
//        }
//        return j
//    }
//
// 3. РАЗДЕЛЕНИЕ ЧЕТНЫХ И НЕЧЕТНЫХ
//    func separateEvenOdd(arr []int) {
//        j := 0
//        for i := 0; i < len(arr); i++ {
//            if arr[i] % 2 == 0 {
//                arr[i], arr[j] = arr[j], arr[i]
//                j++
//            }
//        }
//    }
//
// ============================================================================










