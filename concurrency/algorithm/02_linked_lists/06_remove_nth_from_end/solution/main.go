package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

// ============================================================================
// Решение: Два указателя (two pointers) - оптимальное
// ============================================================================

func removeNthFromEnd(head *ListNode, n int) *ListNode {
	// Создаем dummy node для упрощения обработки corner cases
	dummy := &ListNode{Next: head}
	first := dummy
	second := dummy

	// Сдвигаем первый указатель на n+1 шагов вперед
	for i := 0; i <= n; i++ {
		first = first.Next
	}

	// Двигаем оба указателя до конца списка
	for first != nil {
		first = first.Next
		second = second.Next
	}

	// Удаляем n-й элемент с конца
	second.Next = second.Next.Next

	return dummy.Next
}

// ============================================================================
// Решение 2: Два прохода (менее оптимально)
// ============================================================================

func removeNthFromEndTwoPass(head *ListNode, n int) *ListNode {
	// Первый проход: вычисляем длину списка
	length := 0
	current := head
	for current != nil {
		length++
		current = current.Next
	}

	// Особый случай: удаляем голову
	if length == n {
		return head.Next
	}

	// Второй проход: находим (length - n - 1)-й элемент
	current = head
	for i := 0; i < length-n-1; i++ {
		current = current.Next
	}

	// Удаляем элемент
	current.Next = current.Next.Next

	return head
}

// ============================================================================
// Решение 3: Рекурсия
// ============================================================================

func removeNthFromEndRecursive(head *ListNode, n int) *ListNode {
	_, newHead := removeHelper(head, n)
	return newHead
}

func removeHelper(node *ListNode, n int) (int, *ListNode) {
	if node == nil {
		return 0, nil
	}

	// Рекурсивно идем до конца
	index, nextNode := removeHelper(node.Next, n)

	// index = расстояние от конца (считаем с 1)
	index++

	// Если это n-й элемент с конца, пропускаем его
	if index == n {
		return index, nextNode
	}

	// Иначе присоединяем текущий узел к результату
	node.Next = nextNode
	return index, node
}

// ============================================================================
// Решение 4: С использованием массива указателей
// ============================================================================

func removeNthFromEndArray(head *ListNode, n int) *ListNode {
	// Сохраняем все узлы в массив
	nodes := []*ListNode{}
	current := head
	for current != nil {
		nodes = append(nodes, current)
		current = current.Next
	}

	length := len(nodes)

	// Особый случай: удаляем голову
	if n == length {
		return head.Next
	}

	// Находим узел перед удаляемым
	prevIndex := length - n - 1
	nodes[prevIndex].Next = nodes[prevIndex].Next.Next

	return head
}

// ============================================================================
// Вспомогательные функции
// ============================================================================

func createList(values []int) *ListNode {
	if len(values) == 0 {
		return nil
	}

	head := &ListNode{Val: values[0]}
	current := head

	for i := 1; i < len(values); i++ {
		current.Next = &ListNode{Val: values[i]}
		current = current.Next
	}

	return head
}

func listToSlice(head *ListNode) []int {
	var result []int
	for head != nil {
		result = append(result, head.Val)
		head = head.Next
	}
	return result
}

func printList(head *ListNode) {
	if head == nil {
		fmt.Println("Empty list")
		return
	}
	values := listToSlice(head)
	fmt.Print("[")
	for i, v := range values {
		fmt.Print(v)
		if i < len(values)-1 {
			fmt.Print(", ")
		}
	}
	fmt.Println("]")
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение 1: Два указателя ===")
	testRemoveNth(removeNthFromEnd)

	fmt.Println("\n=== Решение 2: Два прохода ===")
	testRemoveNth(removeNthFromEndTwoPass)

	fmt.Println("\n=== Решение 3: Рекурсия ===")
	testRemoveNth(removeNthFromEndRecursive)

	fmt.Println("\n=== Решение 4: С массивом ===")
	testRemoveNth(removeNthFromEndArray)

	fmt.Println("\n=== Визуализация процесса ===")
	visualizeRemoval()
}

func testRemoveNth(removeFn func(*ListNode, int) *ListNode) {
	testCases := []struct {
		input    []int
		n        int
		expected []int
	}{
		{[]int{1, 2, 3, 4, 5}, 2, []int{1, 2, 3, 5}},
		{[]int{1}, 1, []int{}},
		{[]int{1, 2}, 1, []int{1}},
		{[]int{1, 2}, 2, []int{2}},
		{[]int{1, 2, 3, 4, 5}, 1, []int{1, 2, 3, 4}},
		{[]int{1, 2, 3, 4, 5}, 5, []int{2, 3, 4, 5}},
	}

	for i, tc := range testCases {
		head := createList(tc.input)
		result := removeFn(head, tc.n)
		resultSlice := listToSlice(result)

		status := "✅"
		if len(resultSlice) != len(tc.expected) {
			status = "❌"
		} else {
			for j := 0; j < len(resultSlice); j++ {
				if resultSlice[j] != tc.expected[j] {
					status = "❌"
					break
				}
			}
		}

		fmt.Printf("%s Тест %d: input=%v, n=%d → result=%v (expected=%v)\n",
			status, i+1, tc.input, tc.n, resultSlice, tc.expected)
	}
}

func visualizeRemoval() {
	values := []int{1, 2, 3, 4, 5}
	n := 2

	fmt.Printf("Удаление %d-го элемента с конца из списка %v\n\n", n, values)

	head := createList(values)
	dummy := &ListNode{Next: head}

	fmt.Println("Шаг 1: Создаем dummy node")
	fmt.Println("dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil")
	fmt.Println("  ^")
	fmt.Println("first, second")
	fmt.Println()

	first := dummy
	second := dummy

	fmt.Printf("Шаг 2: Сдвигаем first на n+1=%d шагов вперед\n", n+1)
	for i := 0; i <= n; i++ {
		first = first.Next
		fmt.Printf("  Шаг %d: first передвинут на %d\n", i+1, first.Val)
	}
	fmt.Println("dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil")
	fmt.Println("         ^         ^")
	fmt.Println("      second     first")
	fmt.Println()

	fmt.Println("Шаг 3: Двигаем оба указателя до конца")
	step := 1
	for first != nil {
		first = first.Next
		second = second.Next
		if first != nil {
			fmt.Printf("  Шаг %d: second на %d, first на %d\n", step, second.Val, first.Val)
		} else {
			fmt.Printf("  Шаг %d: second на %d, first на nil\n", step, second.Val)
		}
		step++
	}
	fmt.Println("dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil")
	fmt.Println("                  ^              ^")
	fmt.Println("               second         first")
	fmt.Println()

	fmt.Println("Шаг 4: Удаляем элемент")
	fmt.Printf("  second.Next = %d (удаляемый)\n", second.Next.Val)
	fmt.Printf("  second.Next.Next = %d\n", second.Next.Next.Val)
	second.Next = second.Next.Next
	fmt.Println("  Выполняем: second.Next = second.Next.Next")
	fmt.Println()

	fmt.Println("Результат:")
	fmt.Println("dummy -> 1 -> 2 -> 3 -> 5 -> nil")
	fmt.Println("         ^")
	fmt.Println("      dummy.Next (новая голова)")
}

// ============================================================================
// Объяснение решений
// ============================================================================

// РЕШЕНИЕ 1: Два указателя (ОПТИМАЛЬНОЕ)
//
// ============================================================================
// ВЫСОКОУРОВНЕВАЯ ИДЕЯ
// ============================================================================
//
// Используем два указателя с фиксированным расстоянием между ними:
// - first — "быстрый" указатель, опережает на n+1 позиций
// - second — "медленный" указатель
// - dummy — вспомогательный узел перед головой списка
//
// Алгоритм:
// 1. Создаем dummy node, указывающий на голову
// 2. Сдвигаем first на n+1 шагов вперед от dummy
// 3. Двигаем оба указателя синхронно до конца (пока first != nil)
// 4. Когда first достигнет nil, second окажется перед удаляемым узлом
// 5. Удаляем: second.Next = second.Next.Next
// 6. Возвращаем dummy.Next (новая голова, может измениться)
//
// ============================================================================
// ДЕТАЛЬНЫЙ РАЗБОР КОДА
// ============================================================================
//
// func removeNthFromEnd(head *ListNode, n int) *ListNode {
//     dummy := &ListNode{Next: head}
//
// СТРОКА 1: Создание dummy node
// Зачем?
// - Единообразная обработка всех случаев, включая удаление головы
// - Избегаем специальной проверки if удаляем голову
// - dummy всегда остается неизменным, можем безопасно вернуть dummy.Next
//
// Без dummy:
//     if n == length {
//         return head.Next  // особый случай для головы
//     }
//     // остальной код...
//
// С dummy:
//     // универсальный код для всех случаев
//     return dummy.Next
//
//     first := dummy
//     second := dummy
//
// СТРОКА 2-3: Инициализация указателей
// - Оба начинают с dummy (не с head!)
// - dummy находится "перед" настоящей головой списка
// - Это критично для правильного расчета расстояния
//
//     for i := 0; i <= n; i++ {
//         first = first.Next
//     }
//
// СТРОКА 4-6: Создание "окна" размером n+1
// Почему цикл до i <= n (то есть n+1 итераций)?
//
// МАТЕМАТИКА:
// - Список имеет длину L
// - Удаляем n-й элемент с конца
// - Значит нужен (L-n)-й элемент с начала (0-индексация)
// - Но нам нужен узел ПЕРЕД удаляемым = (L-n-1)-й элемент
// - second должен оказаться на позиции (L-n-1)
//
// - После сдвига first на позицию k от dummy:
//   first находится на k шагов впереди second
//
// - Когда first дойдет до nil (за последним элементом):
//   first прошел L+1 шагов от dummy (L узлов + выход за границу)
//   second прошел (L+1) - (n+1) = L-n шагов от dummy
//   second находится на (L-n)-м узле от dummy
//   Но dummy — это позиция -1, значит second на (L-n-1) от head
//   Это именно узел ПЕРЕД удаляемым! ✓
//
// ПРИМЕР: [1,2,3,4,5], n=2 (удалить 4)
// L = 5, удаляемый с начала = L-n = 3 (4-й элемент, 0-индекс = 3)
// Нужен узел ПЕРЕД ним = 2 (элемент 3)
//
// first сдвиг на n+1 = 3:
// dummy(i=0) -> 1(i=1) -> 2(i=2) -> 3(i=3)
// first теперь на элементе 3, расстояние от second = 3
//
// Синхронное движение:
// first:  3 -> 4 -> 5 -> nil
// second: dummy -> 1 -> 2 -> 3
// Когда first=nil, second на элементе 3 (перед 4) ✓
//
//     for first != nil {
//         first = first.Next
//         second = second.Next
//     }
//
// СТРОКА 7-10: Синхронное движение до конца
// - Двигаем оба указателя с одинаковой скоростью
// - Расстояние между ними остается n+1
// - Останавливаемся когда first == nil (вышел за границу)
// - В этот момент second ГАРАНТИРОВАННО на узле перед удаляемым
//
// ИНВАРИАНТ (всегда выполняется в процессе):
// - Если first находится на k-м узле от dummy
// - То second находится на (k - n - 1)-м узле от dummy
// - Расстояние между ними = n + 1
//
//     second.Next = second.Next.Next
//
// СТРОКА 11: Удаление узла
// - second.Next — это удаляемый узел
// - second.Next.Next — узел после удаляемого
// - Просто "перепрыгиваем" через удаляемый узел
// - Старый узел остается в памяти, но становится недостижимым
// - Go garbage collector автоматически его очистит
//
// Что происходит с памятью:
// До:   second -> [удаляемый] -> следующий
// После: second ----------------> следующий
//                 [удаляемый]  (недостижим, будет удален GC)
//
//     return dummy.Next
// }
//
// СТРОКА 12: Возврат результата
// - Возвращаем dummy.Next, а не head!
// - Почему? Голова могла измениться (если удалили первый элемент)
// - dummy.Next всегда указывает на актуальную голову
//
// ============================================================================
// ВИЗУАЛИЗАЦИЯ РАБОТЫ
// ============================================================================
//
// Пример: [1,2,3,4,5], n=2 (удалить 4)
//
// ШАГ 1: Создание dummy
// dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
//   ^
// first, second
//
// ШАГ 2: Сдвиг first на n+1=3 шагов
// Итерация 0: first = dummy.Next = 1
// Итерация 1: first = 1.Next = 2
// Итерация 2: first = 2.Next = 3
//
// dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
//   ^                ^
// second           first
//
// Расстояние = 3 узла между ними
//
// ШАГ 3: Синхронное движение
// Итерация 1:
//   first = 3.Next = 4
//   second = dummy.Next = 1
// dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
//          ^                ^
//       second           first
//
// Итерация 2:
//   first = 4.Next = 5
//   second = 1.Next = 2
// dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
//                   ^                ^
//                second           first
//
// Итерация 3:
//   first = 5.Next = nil
//   second = 2.Next = 3
// dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
//                        ^              ^
//                     second         first(nil)
//
// ШАГ 4: Удаление
// second (узел 3) -> second.Next (узел 4)
// Выполняем: second.Next = second.Next.Next (узел 5)
//
// dummy -> 1 -> 2 -> 3 -> 5 -> nil
//                        ^
//                     second
//        [4] — удален, недостижим
//
// ШАГ 5: Возврат
// return dummy.Next = узел 1
// Результат: [1,2,3,5] ✓
//
// ============================================================================
// СЛОЖНОСТЬ
// ============================================================================
//
// Временная сложность: O(L), где L - длина списка
// - Сдвиг first: n+1 операций
// - Синхронное движение: L-n операций (от текущей позиции first до конца)
// - Итого: (n+1) + (L-n) = L+1 операций
// - O(L+1) = O(L)
//
// Пространственная сложность: O(1)
// - Используем 3 указателя: dummy, first, second
// - Каждый указатель — 8 байт (на 64-битной системе)
// - Итого: 24 байта = константа
// - Не зависит от размера списка
// - O(1)
//
// ============================================================================
// ПРЕИМУЩЕСТВА РЕШЕНИЯ
// ============================================================================
//
// 1. ОДИН ПРОХОД
//    - Не нужно считать длину списка отдельно
//    - Эффективнее, чем два прохода
//
// 2. O(1) ПАМЯТИ
//    - Только несколько указателей
//    - Масштабируется для списков любой длины
//
// 3. ЭЛЕГАНТНОСТЬ
//    - Короткий и понятный код
//    - Нет сложных условий и проверок
//
// 4. УНИВЕРСАЛЬНОСТЬ
//    - Одна логика для всех случаев
//    - Работает для списков любой длины
//    - Обрабатывает все corner cases автоматически
//
// 5. ПАТТЕРН TWO POINTERS
//    - Стандартная техника для связных списков
//    - Применима ко многим другим задачам
//
// ============================================================================

// РЕШЕНИЕ 2: Два прохода
//
// Идея:
// - Первый проход: вычисляем длину списка L
// - Второй проход: идем до (L-n-1)-го элемента
// - Удаляем следующий элемент
//
// Пример (список [1,2,3,4,5], n=2):
// - L = 5
// - Нужен элемент на позиции L-n-1 = 5-2-1 = 2 (это 3)
// - Удаляем 3.Next (элемент 4)
//
// Временная сложность: O(L)
// - Первый проход: O(L) для подсчета длины
// - Второй проход: O(L-n) для поиска элемента
// - Итого: O(L) + O(L-n) = O(2L) = O(L)
//
// Пространственная сложность: O(1)
// - Используем только переменные (length, current)
//
// Плюсы:
// - Более интуитивное
// - Проще для понимания
// - Явная логика: считаем → находим → удаляем
//
// Минусы:
// - Два прохода вместо одного
// - Больше операций (2L vs L)
// - Требует особую обработку для удаления головы
//
// ============================================================================

// РЕШЕНИЕ 3: Рекурсия
//
// Идея:
// - Рекурсивно идем до конца списка
// - При возврате из рекурсии считаем индекс с конца
// - Когда index == n, пропускаем этот узел
//
// Как работает:
// removeHelper возвращает (index, newHead):
// - index: расстояние от конца списка
// - newHead: новая голова подсписка
//
// Пример (список [1,2,3,4,5], n=2):
// removeHelper(1):
//   removeHelper(2):
//     removeHelper(3):
//       removeHelper(4):
//         removeHelper(5):
//           removeHelper(nil): return (0, nil)
//         index=1, node=5, return (1, 5)
//       index=2, node=4, index==n! return (2, 5) ← пропускаем 4
//     index=3, node=3, 3.Next=5, return (3, 3)
//   index=4, node=2, 2.Next=3, return (4, 2)
// index=5, node=1, 1.Next=2, return (5, 1)
//
// Временная сложность: O(L)
// - Посещаем каждый узел ровно один раз
//
// Пространственная сложность: O(L)
// - Глубина стека рекурсии = L (длина списка)
// - Каждый вызов использует O(1) памяти
// - Итого: O(L) для стека
//
// Почему O(L), а не O(1)?
// - Рекурсия использует стек вызовов
// - Для списка из L элементов — L вызовов на стеке
// - Это дополнительная память!
//
// Плюсы:
// - Элегантное функциональное решение
// - Интересный подход
// - Демонстрирует рекурсивное мышление
//
// Минусы:
// - O(L) памяти для стека
// - Риск stack overflow для больших списков
// - Менее эффективно по памяти
// - Сложнее для понимания
//
// ============================================================================

// РЕШЕНИЕ 4: С массивом
//
// Идея:
// - Сохраняем все узлы в массив
// - Вычисляем индекс удаляемого элемента
// - Удаляем через массив
//
// Временная сложность: O(L)
// - Один проход для заполнения массива: O(L)
// - Поиск и удаление: O(1)
//
// Пространственная сложность: O(L)
// - Создаем массив из L указателей
// - Каждый указатель — 8 байт (на 64-битной системе)
// - Итого: 8L байт дополнительной памяти
//
// Плюсы:
// - Простая реализация
// - Прямой доступ к элементам по индексу
// - Легко модифицировать для других операций
//
// Минусы:
// - O(L) дополнительной памяти
// - Избыточное использование памяти
// - Не подходит для очень больших списков
// - Теряется преимущество связного списка (O(1) вставка/удаление)
//
// ============================================================================

// СРАВНЕНИЕ РЕШЕНИЙ
//
// Критерий          | Решение 1 | Решение 2 | Решение 3 | Решение 4
// ------------------|-----------|-----------|-----------|----------
// Время             | O(L)      | O(L)      | O(L)      | O(L)
// Память            | O(1)      | O(1)      | O(L)      | O(L)
// Проходов          | 1         | 2         | 1         | 1
// Читаемость        | ★★★★      | ★★★★★     | ★★★       | ★★★★★
// Эффективность     | ★★★★★     | ★★★★      | ★★★       | ★★
// Stack safe        | Да        | Да        | Нет       | Да
//
// РЕКОМЕНДАЦИЯ: Решение 1 (два указателя)
// - Оптимально по времени и памяти
// - Один проход по списку
// - Стандартное решение для этой задачи
// - Используется в production коде
//
// ============================================================================

// ============================================================================
// CORNER CASES И ИХ ОБРАБОТКА
// ============================================================================
//
// CASE 1: Удаление единственного элемента
// ----------------------------------------
// Input: head = [1], n = 1
// Ожидаем: []
//
// Пошаговое выполнение:
//
// Шаг 1: Создание dummy
// dummy -> 1 -> nil
//   ^
// first, second
//
// Шаг 2: Сдвиг first на n+1 = 2 шага
// Итерация 0: first = dummy.Next = 1
// Итерация 1: first = 1.Next = nil
// dummy -> 1 -> nil
//   ^            ^
// second      first(nil)
//
// Шаг 3: Синхронное движение
// first уже nil, цикл не выполняется
//
// Шаг 4: Удаление
// second.Next = second.Next.Next
// dummy.Next = 1.Next = nil
// dummy -> nil
//
// Шаг 5: Возврат
// return dummy.Next = nil
// Результат: [] (пустой список) ✓
//
// ПОЧЕМУ РАБОТАЕТ:
// - dummy позволяет обработать случай, когда список становится пустым
// - Без dummy пришлось бы возвращать nil явно
// - С dummy просто возвращаем dummy.Next, который стал nil
//
// ============================================================================
//
// CASE 2: Удаление головы списка
// -------------------------------
// Input: head = [1,2,3], n = 3
// Ожидаем: [2,3]
//
// Пошаговое выполнение:
//
// Шаг 1: Создание dummy
// dummy -> 1 -> 2 -> 3 -> nil
//   ^
// first, second
//
// Шаг 2: Сдвиг first на n+1 = 4 шага
// Итерация 0: first = dummy.Next = 1
// Итерация 1: first = 1.Next = 2
// Итерация 2: first = 2.Next = 3
// Итерация 3: first = 3.Next = nil
// dummy -> 1 -> 2 -> 3 -> nil
//   ^                       ^
// second                 first(nil)
//
// Шаг 3: Синхронное движение
// first уже nil, цикл не выполняется
// second остается на dummy
//
// Шаг 4: Удаление
// second.Next = second.Next.Next
// dummy.Next = 1.Next = 2
// dummy -> 2 -> 3 -> nil
//         [1] — удален
//
// Шаг 5: Возврат
// return dummy.Next = 2
// Результат: [2,3] ✓
//
// ПОЧЕМУ РАБОТАЕТ БЕЗ СПЕЦИАЛЬНОЙ ПРОВЕРКИ:
// - second остается на dummy
// - dummy.Next указывает на голову (элемент 1)
// - После second.Next = second.Next.Next голова меняется на 2
// - Возвращаем dummy.Next, получаем новую голову
//
// БЕЗ DUMMY ПОТРЕБОВАЛОСЬ БЫ:
// if n == length {
//     return head.Next  // особый случай
// }
// // остальной код для других случаев
//
// С DUMMY:
// // универсальный код работает для всех случаев
// return dummy.Next
//
// ============================================================================
//
// CASE 3: Удаление последнего элемента
// -------------------------------------
// Input: head = [1,2,3], n = 1
// Ожидаем: [1,2]
//
// Пошаговое выполнение:
//
// Шаг 1: Создание dummy
// dummy -> 1 -> 2 -> 3 -> nil
//   ^
// first, second
//
// Шаг 2: Сдвиг first на n+1 = 2 шага
// Итерация 0: first = dummy.Next = 1
// Итерация 1: first = 1.Next = 2
// dummy -> 1 -> 2 -> 3 -> nil
//   ^            ^
// second      first
//
// Шаг 3: Синхронное движение
// Итерация 1:
//   first = 2.Next = 3
//   second = dummy.Next = 1
// dummy -> 1 -> 2 -> 3 -> nil
//          ^         ^
//       second    first
//
// Итерация 2:
//   first = 3.Next = nil
//   second = 1.Next = 2
// dummy -> 1 -> 2 -> 3 -> nil
//                   ^         ^
//                second   first(nil)
//
// Шаг 4: Удаление
// second (узел 2) -> second.Next (узел 3)
// second.Next = second.Next.Next = nil
// dummy -> 1 -> 2 -> nil
//                   [3] — удален
//
// Шаг 5: Возврат
// return dummy.Next = 1
// Результат: [1,2] ✓
//
// ОСОБЕННОСТЬ:
// - second.Next.Next = nil корректно обрабатывается
// - Последний элемент удаляется, список укорачивается
//
// ============================================================================
//
// CASE 4: Список из двух элементов
// ---------------------------------
//
// ВАРИАНТ A: Удаление последнего
// Input: head = [1,2], n = 1
// Ожидаем: [1]
//
// Шаг 1: dummy -> 1 -> 2 -> nil
//          ^
//       first, second
//
// Шаг 2: first сдвиг на 2
// dummy -> 1 -> 2 -> nil
//   ^            ^
// second      first
//
// Шаг 3: Синхронное движение (1 итерация)
// dummy -> 1 -> 2 -> nil
//          ^         ^
//       second   first(nil после итерации)
//
// Шаг 4: second на 1, удаляем 2
// 1.Next = 2.Next = nil
// Результат: [1] ✓
//
// ВАРИАНТ B: Удаление первого (головы)
// Input: head = [1,2], n = 2
// Ожидаем: [2]
//
// Шаг 1: dummy -> 1 -> 2 -> nil
//          ^
//       first, second
//
// Шаг 2: first сдвиг на 3
// dummy -> 1 -> 2 -> nil
//   ^                 ^
// second          first(nil)
//
// Шаг 3: Синхронное движение не выполняется (first уже nil)
//
// Шаг 4: second на dummy, удаляем 1
// dummy.Next = 1.Next = 2
// Результат: [2] ✓
//
// ============================================================================
//
// CASE 5: Невалидный n (больше длины списка)
// -------------------------------------------
// Input: head = [1,2], n = 5
//
// ПРОБЛЕМА:
// При сдвиге first на n+1=6 шагов:
// dummy -> 1 -> 2 -> nil
// После 3 шагов first станет nil
// На 4-м шаге попытаемся выполнить first = nil.Next → PANIC!
//
// В PRODUCTION КОДЕ НУЖНА ПРОВЕРКА:
// for i := 0; i <= n; i++ {
//     if first == nil {
//         return head  // или error
//     }
//     first = first.Next
// }
//
// В ЗАДАЧЕ:
// Предполагается, что n всегда валиден (1 ≤ n ≤ length)
// Такая проверка не требуется
//
// ============================================================================
//
// РЕЗЮМЕ: ПОЧЕМУ DUMMY NODE КРИТИЧЕН
// -----------------------------------
//
// 1. ЕДИНООБРАЗНОСТЬ
//    - Одна логика для всех случаев
//    - Не нужны if-ы для проверки "удаляем голову или нет"
//
// 2. БЕЗОПАСНОСТЬ
//    - second ВСЕГДА имеет узел, на который можно ссылаться
//    - Даже при удалении головы second на dummy (валидный узел)
//
// 3. ПРОСТОТА ВОЗВРАТА
//    - dummy.Next ВСЕГДА корректная голова результата
//    - Даже если голова изменилась или список стал пустым
//
// 4. ЧИСТЫЙ КОД
//    - Нет специальных случаев в коде
//    - Легче читать и поддерживать
//    - Меньше вероятность ошибок
//
// СРАВНЕНИЕ:
//
// БЕЗ DUMMY:
// if n == length {
//     return head.Next
// }
// prev := head
// for i := 0; i < length-n-1; i++ {
//     prev = prev.Next
// }
// prev.Next = prev.Next.Next
// return head
//
// С DUMMY:
// dummy := &ListNode{Next: head}
// first, second := dummy, dummy
// for i := 0; i <= n; i++ { first = first.Next }
// for first != nil { first, second = first.Next, second.Next }
// second.Next = second.Next.Next
// return dummy.Next
//
// Код с dummy короче, понятнее и безопаснее!
//
// ============================================================================

// ТЕХНИКА ДВУХ УКАЗАТЕЛЕЙ (TWO POINTERS)
//
// Общий паттерн:
// - Используется для поиска элемента на определенном расстоянии
// - Один указатель опережает другой на фиксированную дистанцию
// - Оба указателя двигаются с одинаковой скоростью
// - Когда первый достигает конца, второй в нужной позиции
//
// Применения:
// 1. Найти k-й элемент с конца
// 2. Найти середину списка (fast/slow pointers)
// 3. Обнаружить цикл в списке (Floyd's algorithm)
// 4. Найти начало цикла
// 5. Проверить палиндром
//
// Преимущества:
// - O(1) памяти
// - Один проход
// - Элегантное решение
//
// ============================================================================
