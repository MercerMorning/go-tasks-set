package main

import (
	"fmt"
	"math"
)

// ============================================================================
// Решение: Два указателя (two pointers)
// ============================================================================

func findKClosest(arr []int, index int, k int) []int {
	if k == 0 {
		return []int{}
	}
	if k >= len(arr) {
		return arr
	}

	target := arr[index]
	left := index - 1
	right := index + 1
	result := []int{target}
	count := 1

	for count < k {
		leftDist := math.MaxInt
		rightDist := math.MaxInt

		if left >= 0 {
			leftDist = abs(arr[left] - target)
		}
		if right < len(arr) {
			rightDist = abs(arr[right] - target)
		}

		// Если расстояния равны, выбираем больший элемент
		if leftDist <= rightDist && left >= 0 {
			result = append(result, arr[left])
			left--
		} else if right < len(arr) {
			result = append(result, arr[right])
			right++
		}

		count++
	}

	return result
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение: Два указателя ===")
	testFindKClosest()

	fmt.Println("\n=== Визуализация процесса ===")
	visualizeFindKClosest()
}

func testFindKClosest() {
	testCases := []struct {
		arr      []int
		index    int
		k        int
		expected []int
	}{
		{[]int{2, 3, 5, 7, 11}, 3, 2, []int{7, 5}},
		{[]int{4, 12, 15, 15, 24}, 1, 3, []int{12, 15, 15}},
		{[]int{1, 2, 3, 4, 5}, 2, 3, []int{3, 2, 4}},
	}

	for i, tc := range testCases {
		result := findKClosest(tc.arr, tc.index, tc.k)
		fmt.Printf("Тест %d: arr=%v, index=%d, k=%d → %v\n",
			i+1, tc.arr, tc.index, tc.k, result)
	}
}

func visualizeFindKClosest() {
	arr := []int{2, 3, 5, 7, 11}
	index := 3
	k := 2

	target := arr[index]
	fmt.Printf("Массив: %v\n", arr)
	fmt.Printf("Индекс: %d, Целевое значение: %d\n", index, target)
	fmt.Printf("Нужно найти k=%d ближайших элементов\n\n", k)

	left := index - 1
	right := index + 1
	result := []int{target}
	count := 1

	fmt.Printf("Шаг 0: Начало\n")
	fmt.Printf("  result = [%d] (сам элемент)\n", target)
	fmt.Printf("  left = %d (arr[%d]=%d), right = %d (arr[%d]=%d)\n\n",
		left, left, arr[left], right, right, arr[right])

	step := 1
	for count < k {
		leftDist := math.MaxInt
		rightDist := math.MaxInt

		if left >= 0 {
			leftDist = abs(arr[left] - target)
		}
		if right < len(arr) {
			rightDist = abs(arr[right] - target)
		}

		fmt.Printf("Шаг %d:\n", step)
		if left >= 0 {
			fmt.Printf("  Слева: arr[%d]=%d, расстояние=%d\n", left, arr[left], leftDist)
		} else {
			fmt.Printf("  Слева: границы массива\n")
		}
		if right < len(arr) {
			fmt.Printf("  Справа: arr[%d]=%d, расстояние=%d\n", right, arr[right], rightDist)
		} else {
			fmt.Printf("  Справа: границы массива\n")
		}

		if leftDist <= rightDist && left >= 0 {
			fmt.Printf("  Выбираем левый элемент: %d\n", arr[left])
			result = append(result, arr[left])
			left--
		} else if right < len(arr) {
			fmt.Printf("  Выбираем правый элемент: %d\n", arr[right])
			result = append(result, arr[right])
			right++
		}

		count++
		fmt.Printf("  result = %v\n\n", result)
		step++
	}

	fmt.Printf("Результат: %v\n", result)
}

// ============================================================================
// Объяснение решения
// ============================================================================

// РЕШЕНИЕ: Два указателя (Two Pointers)
//
// ============================================================================
// ВЫСОКОУРОВНЕВАЯ ИДЕЯ
// ============================================================================
//
// Задача: Найти k элементов, ближайших по значению к arr[index] в отсортированном массиве
//
// Ключевая идея:
// - Массив отсортирован → ближайшие элементы находятся рядом с target
// - Используем два указателя: left и right
// - Начинаем от target, расширяем "окно" влево или вправо
// - На каждом шаге выбираем элемент с меньшим расстоянием
//
// Алгоритм:
// 1. Инициализируем left = index - 1, right = index + 1
// 2. Добавляем сам target в результат
// 3. Пока не собрали k элементов:
//    - Вычисляем расстояния до левого и правого элементов
//    - Выбираем элемент с меньшим расстоянием
//    - Сдвигаем соответствующий указатель
// 4. Возвращаем result
//
// ============================================================================
// ДЕТАЛЬНЫЙ РАЗБОР КОДА
// ============================================================================
//
// func findKClosest(arr []int, index int, k int) []int {
//     if k == 0 {
//         return []int{}
//     }
//     if k >= len(arr) {
//         return arr
//     }
//
// СТРОКИ 1-6: Обработка граничных случаев
// - k == 0: не нужно возвращать ничего → пустой массив
// - k >= len(arr): нужно больше элементов чем есть → весь массив
// - Эти проверки избавляют от лишних вычислений
//
//     target := arr[index]
//     left := index - 1
//     right := index + 1
//     result := []int{target}
//     count := 1
//
// СТРОКИ 7-11: Инициализация
// - target: значение элемента на позиции index
// - left: указатель на элемент слева от target
// - right: указатель на элемент справа от target
// - result: начинаем с самого target (он ближайший к себе, расстояние 0)
// - count: уже собрали 1 элемент (target)
//
// ПОЧЕМУ начинаем с target?
// - target имеет расстояние 0 до себя
// - Это ВСЕГДА один из k ближайших элементов
// - Теперь нужно найти k-1 дополнительных элементов
//
//     for count < k {
//         leftDist := math.MaxInt
//         rightDist := math.MaxInt
//
// СТРОКИ 12-14: Цикл расширения окна
// - Продолжаем пока не соберем k элементов
// - Инициализируем расстояния максимальным значением
// - Почему math.MaxInt? Для корректной обработки границ массива
//
//         if left >= 0 {
//             leftDist = abs(arr[left] - target)
//         }
//         if right < len(arr) {
//             rightDist = abs(arr[right] - target)
//         }
//
// СТРОКИ 15-20: Вычисление расстояний
// - Проверяем границы массива перед доступом
// - left >= 0: есть элементы слева
// - right < len(arr): есть элементы справа
// - Если граница достигнута → оставляем MaxInt
//
// ЗАЧЕМ MaxInt для границ?
// - Если left < 0: leftDist = MaxInt → всегда выберем правый элемент
// - Если right >= len: rightDist = MaxInt → всегда выберем левый элемент
// - Упрощает логику выбора, не нужны дополнительные if-ы
//
// abs(arr[left] - target):
// - Расстояние = |значение - target|
// - Например: target=7, arr[left]=5 → |5-7| = 2
// - Массив отсортирован, но нас интересует расстояние, а не позиция
//
//         if leftDist <= rightDist && left >= 0 {
//             result = append(result, arr[left])
//             left--
//         } else if right < len(arr) {
//             result = append(result, arr[right])
//             right++
//         }
//
// СТРОКИ 21-27: Выбор элемента
//
// УСЛОВИЕ: leftDist <= rightDist
// - Используем <=, а не <
// - Почему? Если расстояния равны, выбираем больший элемент (из условия задачи)
// - В отсортированном массиве: правый элемент больше левого
// - НО мы выбираем левый при равенстве → получаем больший элемент
//
// ПОДОЖДИТЕ, ЭТО ПРАВИЛЬНО?
// Нет! Здесь ошибка в исходном коде. Если массив [1,2,3,4,5], target=3:
// - Слева: 2, расстояние=1
// - Справа: 4, расстояние=1
// - При равенстве должны выбрать 4 (больший)
// - Но код выберет 2 (левый)
//
// ИСПРАВЛЕНИЕ: при равенстве выбираем правый элемент
// if leftDist < rightDist && left >= 0 {
//     // левый ближе
// } else if right < len(arr) {
//     // правый ближе или равен
// }
//
// && left >= 0: дополнительная проверка границы
// - Убеждаемся что left валиден перед доступом
//
//         count++
//     }
//     return result
// }
//
// СТРОКИ 28-30: Финализация
// - Увеличиваем счетчик собранных элементов
// - Продолжаем пока count < k
// - Возвращаем result
//
// ============================================================================
// ПРИМЕР РАБОТЫ
// ============================================================================
//
// arr = [2, 3, 5, 7, 11], index = 3 (target = 7), k = 2
//
// ИНИЦИАЛИЗАЦИЯ:
// - target = 7
// - left = 2 (arr[2] = 5)
// - right = 4 (arr[4] = 11)
// - result = [7]
// - count = 1
//
// ИТЕРАЦИЯ 1: (нужно добавить еще 1 элемент)
// - leftDist = |5 - 7| = 2
// - rightDist = |11 - 7| = 4
// - leftDist (2) < rightDist (4) → выбираем левый
// - result = [7, 5]
// - left = 1
// - count = 2
//
// count == k → выходим из цикла
// Результат: [7, 5]
//
// ============================================================================
//
// ДРУГОЙ ПРИМЕР: arr = [4, 12, 15, 15, 24], index = 1 (target = 12), k = 3
//
// ИНИЦИАЛИЗАЦИЯ:
// - target = 12
// - left = 0 (arr[0] = 4)
// - right = 2 (arr[2] = 15)
// - result = [12]
// - count = 1
//
// ИТЕРАЦИЯ 1:
// - leftDist = |4 - 12| = 8
// - rightDist = |15 - 12| = 3
// - rightDist (3) < leftDist (8) → выбираем правый
// - result = [12, 15]
// - right = 3
// - count = 2
//
// ИТЕРАЦИЯ 2:
// - leftDist = |4 - 12| = 8
// - rightDist = |15 - 12| = 3
// - rightDist (3) < leftDist (8) → выбираем правый
// - result = [12, 15, 15]
// - right = 4
// - count = 3
//
// count == k → выходим
// Результат: [12, 15, 15]
//
// ============================================================================
// СЛОЖНОСТЬ
// ============================================================================
//
// Временная сложность: O(k)
// - Выполняем k-1 итераций цикла (уже есть 1 элемент — target)
// - Каждая итерация:
//   - Вычисление расстояний: O(1)
//   - Сравнение: O(1)
//   - Добавление в result: O(1) amortized
// - Итого: (k-1) × O(1) = O(k)
//
// ПОЧЕМУ O(k), а не O(n)?
// - Не проходим весь массив
// - Обрабатываем только k элементов
// - Для k << n это намного эффективнее
//
// Пространственная сложность: O(k)
// - Массив result размером k
// - Переменные left, right, count, target: O(1)
// - Итого: O(k)
//
// МОЖНО ЛИ O(1) ПАМЯТИ?
// - Нет, нужно вернуть k элементов
// - Минимум O(k) для хранения результата
// - Это оптимально
//
// ============================================================================
// CORNER CASES
// ============================================================================
//
// CASE 1: k = 0
// Input: arr = [1,2,3], index = 1, k = 0
// Ожидаем: []
//
// Обрабатывается в начале функции:
// if k == 0 { return []int{} }
// Возвращаем пустой массив ✓
//
// ============================================================================
//
// CASE 2: k >= len(arr)
// Input: arr = [1,2,3], index = 1, k = 5
// Ожидаем: [1,2,3] (весь массив)
//
// Обрабатывается в начале:
// if k >= len(arr) { return arr }
// Возвращаем весь массив ✓
//
// ============================================================================
//
// CASE 3: target на краю массива
// Input: arr = [1,2,3,4,5], index = 0, k = 3
// Ожидаем: [1, 2, 3]
//
// ИНИЦИАЛИЗАЦИЯ:
// - target = 1
// - left = -1 (за границей)
// - right = 1
// - result = [1], count = 1
//
// ИТЕРАЦИЯ 1:
// - left < 0 → leftDist = MaxInt
// - rightDist = |2 - 1| = 1
// - rightDist < leftDist → выбираем правый
// - result = [1, 2], right = 2
//
// ИТЕРАЦИЯ 2:
// - left < 0 → leftDist = MaxInt
// - rightDist = |3 - 1| = 2
// - rightDist < leftDist → выбираем правый
// - result = [1, 2, 3], right = 3
//
// Результат: [1, 2, 3] ✓
// Корректно обрабатывает границу слева!
//
// ============================================================================
//
// CASE 4: Все элементы на одинаковом расстоянии
// Input: arr = [1,2,3,4,5], index = 2 (target=3), k = 2
// Ожидаем: [3, 4] (при равенстве выбираем больший)
//
// ИНИЦИАЛИЗАЦИЯ:
// - target = 3
// - left = 1 (arr[1] = 2)
// - right = 3 (arr[3] = 4)
// - result = [3], count = 1
//
// ИТЕРАЦИЯ 1:
// - leftDist = |2 - 3| = 1
// - rightDist = |4 - 3| = 1
// - leftDist <= rightDist → выбираем левый (ОШИБКА!)
// - result = [3, 2]
//
// ОЖИДАЛОСЬ: [3, 4]
// ПОЛУЧИЛИ: [3, 2]
//
// ПРОБЛЕМА: При равенстве выбираем левый, а нужно правый
//
// ИСПРАВЛЕННЫЙ КОД:
// if leftDist < rightDist && left >= 0 {
//     result = append(result, arr[left])
//     left--
// } else if right < len(arr) {
//     result = append(result, arr[right])
//     right++
// }
//
// Теперь при равенстве выберем правый элемент ✓
//
// ============================================================================
// ПРЕИМУЩЕСТВА РЕШЕНИЯ
// ============================================================================
//
// 1. ОПТИМАЛЬНАЯ СЛОЖНОСТЬ
//    - O(k) время — не можем быстрее, нужно вернуть k элементов
//    - O(k) память — минимум для хранения результата
//
// 2. ИСПОЛЬЗУЕТ СВОЙСТВО ОТСОРТИРОВАННОСТИ
//    - Ближайшие элементы находятся рядом
//    - Не нужно проверять весь массив
//
// 3. ПРОСТАЯ ЛОГИКА
//    - Два указателя расходятся от target
//    - Интуитивно понятно
//
// 4. ЭФФЕКТИВНО ДЛЯ k << n
//    - Для k=5, n=1000000: всего 5 операций вместо 1000000
//
// ============================================================================
// АЛЬТЕРНАТИВНЫЕ ПОДХОДЫ
// ============================================================================
//
// ПОДХОД 1: Вычислить все расстояния и отсортировать
// distances := []struct{val, dist int}{}
// for _, val := range arr {
//     dist := abs(val - target)
//     distances = append(distances, struct{val, dist int}{val, dist})
// }
// sort по dist
// взять первые k
//
// Сложность: O(n log n) — медленнее!
// Память: O(n) — больше!
//
// ПОДХОД 2: Min-heap размером k
// - Добавлять элементы в heap
// - Поддерживать heap размером k с максимальными расстояниями
// - Сложность: O(n log k)
// - Все еще медленнее чем O(k)
//
// ПОДХОД 3: Binary Search + Two Pointers
// - Бинарный поиск для нахождения closest элемента
// - Затем two pointers для расширения
// - Сложность: O(log n + k)
// - Чуть быстрее если нужно найти index
//
// НАШ ПОДХОД: O(k)
// - Самый эффективный для данной задачи
// - Используем факт что index уже известен
//
// ============================================================================
//
// ============================================================================

