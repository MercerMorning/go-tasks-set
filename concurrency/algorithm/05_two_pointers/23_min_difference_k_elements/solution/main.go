package main

import (
	"fmt"
	"sort"
)

// ============================================================================
// Решение: Сортировка и скользящее окно
// ============================================================================

func minDifference(nums []int, k int) int {
	// Сортируем массив
	sorted := make([]int, len(nums))
	copy(sorted, nums)
	sort.Ints(sorted)

	// Инициализируем минимальную разницу максимальным значением
	minDiff := sorted[len(sorted)-1] - sorted[0]

	// Используем скользящее окно размера k
	// Разница между максимальным и минимальным в окне = sorted[i+k-1] - sorted[i]
	for i := 0; i <= len(sorted)-k; i++ {
		diff := sorted[i+k-1] - sorted[i]
		if diff < minDiff {
			minDiff = diff
		}
	}

	return minDiff
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение: Минимальная разница между k элементами ===")
	testMinDifference()
}

func testMinDifference() {
	nums := []int{1, 3, 5, 7, 9}
	k := 3

	result := minDifference(nums, k)
	fmt.Printf("Результат: %d (ожидается 4)\n", result)

	// Пояснение:
	// Отсортированный массив: [1, 3, 5, 7, 9]
	// Окно [1, 3, 5]: разница = 5 - 1 = 4
	// Окно [3, 5, 7]: разница = 7 - 3 = 4
	// Окно [5, 7, 9]: разница = 9 - 5 = 4
	// Минимум: 4
}

// ============================================================================
// Объяснение решения
// ============================================================================

// РЕШЕНИЕ: Сортировка и скользящее окно
//
// Идея:
// - Чтобы минимизировать разницу между k элементами, нужно выбрать k последовательных элементов в отсортированном массиве
// - После сортировки используем скользящее окно размера k
// - Разница в окне = максимальный элемент - минимальный элемент = sorted[i+k-1] - sorted[i]
//
// Алгоритм:
// 1. Сортируем массив: O(n log n)
// 2. Используем скользящее окно размера k:
//    - Для каждого окна [i, i+k-1] вычисляем разницу
//    - Обновляем минимальную разницу
// 3. Возвращаем минимальную разницу
//
// Пример работы:
// nums = [1, 3, 5, 7, 9]
// k = 3
//
// Шаг 1: Сортируем (уже отсортирован)
//   sorted = [1, 3, 5, 7, 9]
//
// Шаг 2: Скользящее окно
//   Окно 1: [1, 3, 5] (индексы 0-2)
//     diff = sorted[2] - sorted[0] = 5 - 1 = 4
//     minDiff = 4
//
//   Окно 2: [3, 5, 7] (индексы 1-3)
//     diff = sorted[3] - sorted[1] = 7 - 3 = 4
//     minDiff = min(4, 4) = 4
//
//   Окно 3: [5, 7, 9] (индексы 2-4)
//     diff = sorted[4] - sorted[2] = 9 - 5 = 4
//     minDiff = min(4, 4) = 4
//
// Результат: 4
//
// Временная сложность: O(n log n)
// - Сортировка: O(n log n)
// - Скользящее окно: O(n - k) = O(n)
// - Итого: O(n log n)
//
// Пространственная сложность: O(n)
// - Копия массива для сортировки: O(n)
// - Остальные переменные: O(1)
// - Итого: O(n)
//
// Почему сортировка?
// - После сортировки элементы упорядочены
// - Минимальная разница между k элементами достигается при выборе k последовательных элементов
// - Это интуитивно: чтобы минимизировать разницу, нужно выбрать элементы, которые близки друг к другу
//
// Почему скользящее окно работает?
// - После сортировки оптимальное решение - выбрать k последовательных элементов
// - Перебираем все возможные окна размера k
// - Выбираем окно с минимальной разницей
//
// Доказательство оптимальности:
// - Предположим, оптимальное решение содержит элементы не в одном окне
// - Тогда можно заменить один из элементов на элемент из окна между ними
// - Это уменьшит разницу, что противоречит оптимальности
// - Значит, оптимальное решение - это окно из k последовательных элементов
