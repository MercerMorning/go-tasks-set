package main

import (
	"fmt"
	"sort"
)

// ============================================================================
// Решение: Сортировка и два указателя
// ============================================================================

func minAbsoluteDifference(arr1 []int, arr2 []int) int {
	// Сортируем оба массива
	sorted1 := make([]int, len(arr1))
	copy(sorted1, arr1)
	sort.Ints(sorted1)

	sorted2 := make([]int, len(arr2))
	copy(sorted2, arr2)
	sort.Ints(sorted2)

	minDiff := abs(sorted1[0] - sorted2[0])

	// Используем два указателя для поиска минимальной разницы
	i, j := 0, 0
	for i < len(sorted1) && j < len(sorted2) {
		diff := abs(sorted1[i] - sorted2[j])
		if diff < minDiff {
			minDiff = diff
		}

		// Двигаем указатель того массива, у которого текущий элемент меньше
		if sorted1[i] < sorted2[j] {
			i++
		} else {
			j++
		}
	}

	return minDiff
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение: Минимальная разница между двумя массивами ===")
	testMinAbsoluteDifference()
}

func testMinAbsoluteDifference() {
	arr1 := []int{1, 10, 15, 4, 20}
	arr2 := []int{3, 16, 5, 7}

	result := minAbsoluteDifference(arr1, arr2)
	fmt.Printf("Результат: %d (ожидается 1)\n", result)

	// Пояснение:
	// Отсортированные массивы:
	//   arr1: [1, 4, 10, 15, 20]
	//   arr2: [3, 5, 7, 16]
	// Минимальная разница: |4-5| = 1 или |15-16| = 1
}

// ============================================================================
// Объяснение решения
// ============================================================================

// РЕШЕНИЕ: Сортировка и два указателя
//
// Идея:
// - Сортируем оба массива
// - Используем два указателя для эффективного поиска минимальной разницы
// - Двигаем указатель того массива, у которого текущий элемент меньше
// - Это гарантирует, что мы не пропустим оптимальную пару
//
// Алгоритм:
// 1. Сортируем оба массива: O(n log n + m log m)
// 2. Инициализируем указатели i=0, j=0
// 3. Пока оба указателя в пределах массивов:
//    - Вычисляем разницу между текущими элементами
//    - Обновляем минимальную разницу
//    - Двигаем указатель того массива, у которого элемент меньше
// 4. Возвращаем минимальную разницу
//
// Пример работы:
// arr1 = [1, 10, 15, 4, 20]
// arr2 = [3, 16, 5, 7]
//
// Шаг 1: Сортируем
//   sorted1 = [1, 4, 10, 15, 20]
//   sorted2 = [3, 5, 7, 16]
//
// Шаг 2: Два указателя
//   i=0, j=0: sorted1[0]=1, sorted2[0]=3
//     diff = |1-3| = 2
//     minDiff = 2
//     sorted1[0] < sorted2[0] → i=1
//
//   i=1, j=0: sorted1[1]=4, sorted2[0]=3
//     diff = |4-3| = 1 ← новый минимум!
//     minDiff = 1
//     sorted1[1] > sorted2[0] → j=1
//
//   i=1, j=1: sorted1[1]=4, sorted2[1]=5
//     diff = |4-5| = 1
//     minDiff = 1
//     sorted1[1] < sorted2[1] → i=2
//
//   i=2, j=1: sorted1[2]=10, sorted2[1]=5
//     diff = |10-5| = 5
//     minDiff = 1
//     sorted1[2] > sorted2[1] → j=2
//
//   i=2, j=2: sorted1[2]=10, sorted2[2]=7
//     diff = |10-7| = 3
//     minDiff = 1
//     sorted1[2] > sorted2[2] → j=3
//
//   i=2, j=3: sorted1[2]=10, sorted2[3]=16
//     diff = |10-16| = 6
//     minDiff = 1
//     sorted1[2] < sorted2[3] → i=3
//
//   i=3, j=3: sorted1[3]=15, sorted2[3]=16
//     diff = |15-16| = 1
//     minDiff = 1
//     sorted1[3] < sorted2[3] → i=4
//
//   i=4, j=3: sorted1[4]=20, sorted2[3]=16
//     diff = |20-16| = 4
//     minDiff = 1
//     sorted1[4] > sorted2[3] → j=4 (выход из цикла)
//
// Результат: 1
//
// Временная сложность: O(n log n + m log m)
// - n - размер arr1
// - m - размер arr2
// - Сортировка arr1: O(n log n)
// - Сортировка arr2: O(m log m)
// - Два указателя: O(n + m)
// - Итого: O(n log n + m log m)
//
// Пространственная сложность: O(n + m)
// - Копии массивов для сортировки: O(n + m)
// - Остальные переменные: O(1)
// - Итого: O(n + m)
//
// Почему два указателя работают?
// - После сортировки элементы упорядочены
// - Если sorted1[i] < sorted2[j], то:
//   - sorted1[i] ближе к sorted2[j], чем к sorted2[j+1]
//   - Можно безопасно двигать i, не пропустив оптимальную пару
// - Аналогично для sorted2[j] < sorted1[i]
//
// Почему не перебирать все пары?
// - Наивный подход: O(n * m) - перебрать все пары
// - С двумя указателями: O(n + m) после сортировки
// - Для больших массивов значительно быстрее
//
// Пример: n=1000, m=1000
// - Наивный: 1,000,000 операций
// - Два указателя: 2000 операций после сортировки
// - Ускорение в 500 раз!
