package main

import (
	"fmt"
	"sort"
)

// ============================================================================
// Решение 1: Сортировка символов (простое и понятное)
// ============================================================================

func IsAnagram(a, b string) bool {
	// Если длины разные, точно не анаграммы
	if len(a) != len(b) {
		return false
	}

	// Преобразуем строки в рунные слайсы и сортируем
	runesA := []rune(a)
	runesB := []rune(b)

	sort.Slice(runesA, func(i, j int) bool { return runesA[i] < runesB[j] })
	sort.Slice(runesB, func(i, j int) bool { return runesB[i] < runesB[j] })

	// Сравниваем отсортированные слайсы
	for i := 0; i < len(runesA); i++ {
		if runesA[i] != runesB[i] {
			return false
		}
	}

	return true
}

// ============================================================================
// Решение 2: Hash map с подсчетом символов (оптимальное)
// ============================================================================

func IsAnagramMap(a, b string) bool {
	if len(a) != len(b) {
		return false
	}

	// Подсчитываем частоту каждой руны
	counts := make(map[rune]int)

	// Увеличиваем счетчик для символов из a
	for _, r := range a {
		counts[r]++
	}

	// Уменьшаем счетчик для символов из b
	for _, r := range b {
		counts[r]--
		if counts[r] < 0 {
			return false
		}
	}

	// Проверяем, что все счетчики равны 0
	for _, count := range counts {
		if count != 0 {
			return false
		}
	}

	return true
}

// ============================================================================
// Решение 3: Одна map с инкрементом/декрементом
// ============================================================================

func IsAnagramOptimized(a, b string) bool {
	if len(a) != len(b) {
		return false
	}

	counts := make(map[rune]int)

	// Одновременно обрабатываем обе строки
	runesA := []rune(a)
	runesB := []rune(b)

	for i := 0; i < len(runesA); i++ {
		counts[runesA[i]]++
		counts[runesB[i]]--
	}

	// Если анаграммы, все счетчики должны быть 0
	for _, count := range counts {
		if count != 0 {
			return false
		}
	}

	return true
}

// ============================================================================
// Демонстрация и тесты
// ============================================================================

func main() {
	fmt.Println("=== Решение 1: Сортировка ===")
	testIsAnagram(IsAnagram)

	fmt.Println("\n=== Решение 2: Hash Map ===")
	testIsAnagram(IsAnagramMap)

	fmt.Println("\n=== Решение 4: Оптимизированная Map ===")
	testIsAnagram(IsAnagramOptimized)

	fmt.Println("\n=== Визуализация процесса ===")
	visualizeAnagram()
}

func testIsAnagram(fn func(string, string) bool) {
	testCases := []struct {
		a, b     string
		expected bool
	}{
		{"лапоть", "пальто", true},
		{"listen", "silent", true},
		{"hello", "world", false},
		{"", "", true},
		{"a", "b", false},
		{"abc", "cba", true},
		{"aabbcc", "abcabc", true},
	}

	for _, tc := range testCases {
		result := fn(tc.a, tc.b)
		status := "✅"
		if result != tc.expected {
			status = "❌"
		}
		fmt.Printf("%s IsAnagram('%s', '%s') = %v (ожидалось %v)\n",
			status, tc.a, tc.b, result, tc.expected)
	}
}

func visualizeAnagram() {
	a := "listen"
	b := "silent"

	fmt.Printf("Проверка анаграммы: '%s' и '%s'\n\n", a, b)

	fmt.Println("Метод 1: Сортировка")
	sortedA := []rune(a)
	sortedB := []rune(b)
	sort.Slice(sortedA, func(i, j int) bool { return sortedA[i] < sortedA[j] })
	sort.Slice(sortedB, func(i, j int) bool { return sortedB[i] < sortedB[j] })
	fmt.Printf("  '%s' → '%s'\n", a, string(sortedA))
	fmt.Printf("  '%s' → '%s'\n", b, string(sortedB))
	fmt.Printf("  Равны? %v\n\n", string(sortedA) == string(sortedB))

	fmt.Println("Метод 2: Подсчет символов")
	counts := make(map[rune]int)
	for _, r := range a {
		counts[r]++
	}
	fmt.Printf("  После обработки '%s': %v\n", a, counts)

	for _, r := range b {
		counts[r]--
	}
	fmt.Printf("  После обработки '%s': %v\n", b, counts)

	allZero := true
	for _, count := range counts {
		if count != 0 {
			allZero = false
			break
		}
	}
	fmt.Printf("  Все счетчики = 0? %v\n", allZero)
}

// ============================================================================
// Объяснение решений
// ============================================================================

// РЕШЕНИЕ 1: Сортировка
//
// Идея:
// - Сортируем символы обеих строк
// - Если строки — анаграммы, отсортированные версии идентичны
// - Пример: "listen" → "eilnst", "silent" → "eilnst"
//
// Временная сложность: O(n log n)
// - Преобразование в рунные слайсы: O(n)
// - Сортировка двух слайсов: 2 × O(n log n) = O(n log n)
// - Сравнение отсортированных: O(n)
// - Итого: O(n) + O(n log n) + O(n) = O(n log n)
//
// Пространственная сложность: O(n)
// - Два рунных слайса размером n
// - sort.Slice работает in-place, но нужна память для рекурсии: O(log n)
// - Итого: O(n)
//
// Плюсы:
// - Простая реализация
// - Интуитивно понятная
// - Короткий код
//
// Минусы:
// - Не оптимальная по времени (O(n log n) вместо O(n))
// - Требует дополнительной памяти для копий
//
// ============================================================================

// РЕШЕНИЕ 2: Hash Map (ОПТИМАЛЬНОЕ)
//
// Идея:
// - Подсчитываем частоту каждого символа в первой строке
// - Вычитаем частоты символов второй строки
// - Если анаграммы, все счетчики должны быть 0
//
// Алгоритм:
// 1. Для строки "listen":
//    counts = {l:1, i:1, s:1, t:1, e:1, n:1}
// 2. Для строки "silent":
//    counts = {l:0, i:0, s:0, t:0, e:0, n:0}
// 3. Все нули → анаграмма ✓
//
// Временная сложность: O(n)
// - Первый цикл (по a): O(n) операций
// - Второй цикл (по b): O(n) операций
// - Проверка счетчиков: O(k), где k — количество уникальных символов, k ≤ n
// - Итого: O(n) + O(n) + O(k) = O(n)
//
// Почему O(n), а не O(n + k)?
// - k ≤ n (не может быть больше уникальных символов, чем длина строки)
// - O(n + k) = O(n + n) = O(n)
//
// Пространственная сложность: O(k)
// - Map хранит до k уникальных символов
// - В худшем случае: k = n (все символы уникальны)
// - В лучшем случае: k = 1 (все символы одинаковые)
// - Итого: O(k), где k ≤ n
//
// Плюсы:
// - Оптимальная временная сложность O(n)
// - Работает с Unicode
// - Один проход по каждой строке
//
// Минусы:
// - Чуть сложнее реализация
// - Дополнительная память для map
//
// ============================================================================
// РЕШЕНИЕ 3: Оптимизированная Map
//
// Идея:
// - Обрабатываем обе строки в одном цикле
// - Инкремент для первой строки, декремент для второй
// - Меньше проходов по данным
//
// Временная сложность: O(n)
// - Один цикл: O(n)
// - Проверка счетчиков: O(k)
// - Итого: O(n)
//
// Пространственная сложность: O(k)
// - Map с до k элементами
//
// Плюсы:
// - Один цикл вместо двух
// - Немного быстрее на практике
// - Те же гарантии асимптотики
//
// Минусы:
// - Менее читаемый код
// - Незначительное улучшение
//
// ============================================================================

// СРАВНЕНИЕ РЕШЕНИЙ
//
// Критерий          | Решение 1   | Решение 2 | Решение 3
// ------------------|-------------|-----------|----------
// Время             | O(n log n)  | O(n)      |  O(n)
// Память            | O(n)        | O(k)      |  O(k)
// Unicode           | Да          | Да        |  Да
// Читаемость        | ★★★★★       | ★★★★      |  ★★★
// Производительность| ★★★         | ★★★★      |  ★★★★
//
// РЕКОМЕНДАЦИИ:
// - Unicode строки → Решение 2 (оптимальное)
// - Простота важнее → Решение 1 (самое понятное)
//
// ============================================================================
// CORNER CASES
//
// 1. Пустые строки:
//    IsAnagram("", "") → true
//    Пустая строка — анаграмма пустой строки
//
// 2. Одна пустая:
//    IsAnagram("", "a") → false
//    Разные длины
//
// 3. Регистр:
//    IsAnagram("Listen", "Silent") → false
//    'L' != 'l'
//    Если нужно игнорировать регистр: strings.ToLower()
//
// 4. Пробелы:
//    IsAnagram("a b", "ba ") → true
//    Пробел — обычный символ
//
// 5. Unicode:
//    IsAnagram("café", "éfac") → true
//    Решение 2/4 работает, Решение 3 НЕТ
//
// 6. Дубликаты:
//    IsAnagram("aab", "aba") → true
//    Важно правильно считать частоты
//
// 7. Разные символы, одинаковая длина:
//    IsAnagram("abc", "def") → false
//
// ============================================================================

// МОДИФИКАЦИИ ЗАДАЧИ
//
// 1. ИГНОРИРОВАТЬ РЕГИСТР
//    func IsAnagramCaseInsensitive(a, b string) bool {
//        a = strings.ToLower(a)
//        b = strings.ToLower(b)
//        return IsAnagram(a, b)
//    }
//
// 2. ИГНОРИРОВАТЬ ПРОБЕЛЫ
//    func IsAnagramNoSpaces(a, b string) bool {
//        a = strings.ReplaceAll(a, " ", "")
//        b = strings.ReplaceAll(b, " ", "")
//        return IsAnagram(a, b)
//    }
//
// 3. ИГНОРИРОВАТЬ СПЕЦИАЛЬНЫЕ СИМВОЛЫ
//    func IsAnagramAlphaOnly(a, b string) bool {
//        // Оставить только буквы
//        return IsAnagram(filterAlpha(a), filterAlpha(b))
//    }
//
// 4. НАЙТИ ВСЕ АНАГРАММЫ СЛОВА В ТЕКСТЕ
//    func FindAnagrams(text, word string) []int {
//        // Скользящее окно размером len(word)
//        // Проверяем каждое окно на анаграмму
//    }
//
// 5. ГРУППИРОВКА АНАГРАММ
//    Дан массив строк, сгруппировать анаграммы:
//    ["eat","tea","tan","ate","nat","bat"]
//    → [["eat","tea","ate"], ["tan","nat"], ["bat"]]
//
// ============================================================================

// ПРИМЕНЕНИЕ В РЕАЛЬНЫХ ЗАДАЧАХ
//
// 1. ПОИСК АНАГРАММ В ТЕКСТЕ
//    - Скользящее окно
//    - LeetCode: "Find All Anagrams in a String"
//
// 2. ГРУППИРОВКА АНАГРАММ
//    - Hash map с отсортированной строкой как ключ
//    - LeetCode: "Group Anagrams"
//
// 3. ПРОВЕРКА PERMUTATION
//    - Анаграмма = перестановка символов
//    - Useful для строковых алгоритмов
//
// 4. SPELL CHECKERS
//    - Поиск похожих слов
//    - "Возможно, вы имели в виду..."
//
// 5. ИГРЫ СО СЛОВАМИ
//    - Scrabble, Words With Friends
//    - Проверка валидности слов
//
// ============================================================================










