package main

import (
	"fmt"
	"strings"
)

// ============================================================================
// Решение
// ============================================================================

func reverseWords(s string) string {
	words := strings.Split(s, " ")
	result := make([]string, len(words))

	for i, word := range words {
		if isPalindrome(word) {
			result[i] = word
		} else {
			result[i] = reverseString(word)
		}
	}

	return strings.Join(result, " ")
}

func isPalindrome(s string) bool {
	runes := []rune(s)
	left, right := 0, len(runes)-1

	for left < right {
		if runes[left] != runes[right] {
			return false
		}
		left++
		right--
	}

	return true
}

func reverseString(s string) string {
	runes := []rune(s)
	left, right := 0, len(runes)-1

	for left < right {
		runes[left], runes[right] = runes[right], runes[left]
		left++
		right--
	}

	return string(runes)
}

func main() {
	fmt.Println("=== Решение ===")

	testCases := []struct {
		input    string
		expected string
	}{
		{"Hello worlD ollo", "olleH Dlrow ollo"},
		{"привет мир ара", "тевирп рим ара"},
		{"", ""},
		{"civic level deed", "civic level deed"},
	}

	for _, tc := range testCases {
		result := reverseWords(tc.input)
		status := "✅"
		if result != tc.expected {
			status = "❌"
		}
		fmt.Printf("%s reverseWords('%s') = '%s' (expected '%s')\n",
			status, tc.input, result, tc.expected)
	}
}

// ============================================================================
// Объяснение решения
// ============================================================================

// РЕШЕНИЕ: Разбиение на слова, проверка палиндрома и реверс
//
// Идея:
// - Разбиваем строку на слова
// - Для каждого слова проверяем, является ли оно палиндромом
// - Если палиндром - оставляем как есть
// - Если не палиндром - реверсируем
// - Собираем результат обратно в строку
//
// Алгоритм:
// 1. Разбиваем строку на слова через пробелы
// 2. Для каждого слова:
//    - Проверяем, является ли оно палиндромом
//    - Если да - оставляем без изменений
//    - Если нет - реверсируем
// 3. Собираем слова обратно в строку через пробелы
//
// Пример работы:
// s = "Hello worlD ollo"
//
// Шаг 1: Разбиение на слова
//   words = ["Hello", "worlD", "ollo"]
//
// Шаг 2: Обработка каждого слова
//   "Hello": не палиндром → реверс → "olleH"
//   "worlD": не палиндром → реверс → "Dlrow"
//   "ollo": палиндром → оставляем → "ollo"
//
// Шаг 3: Сборка результата
//   result = "olleH Dlrow ollo"
//
// Временная сложность: O(n)
// - n - общая длина строки
// - Разбиение на слова: O(n)
// - Проверка палиндрома для каждого слова: O(m), где m - длина слова
// - Реверс для каждого слова: O(m)
// - Суммарно для всех слов: O(n)
// - Сборка результата: O(n)
// - Итого: O(n)
//
// Пространственная сложность: O(n)
// - Массив words: O(n)
// - Результат: O(n)
// - Временные массивы для реверса: O(m) для каждого слова, но не одновременно
// - Итого: O(n)
//
// Почему используем []rune вместо []byte?
// - []rune корректно обрабатывает Unicode символы (например, кириллицу)
// - []byte работает только с ASCII и может некорректно обработать многобайтовые символы
// - Для задачи с поддержкой разных языков []rune предпочтительнее
//
// Пример с Unicode:
// s = "привет мир ара"
// - "привет": не палиндром → "тевирп"
// - "мир": не палиндром → "рим"
// - "ара": палиндром → "ара"
// Результат: "тевирп рим ара"
//
// Альтернатива: можно использовать strings.Builder для оптимизации
// - Но для собеседований текущее решение достаточно понятное и эффективное

